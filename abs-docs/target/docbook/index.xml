<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered maxdepth="2"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>ABS Documentation</title>
<date>2018-03-01</date>
<author>
<personname>
<firstname>ABS</firstname>
<othername>Development</othername>
<surname>Team</surname>
</personname>
</author>
<authorinitials>ADT</authorinitials>
<revhistory>
<revision>
<revnumber></revnumber>
<date>2018-03-01</date>
<authorinitials>ADT</authorinitials>
</revision>
</revhistory>
</info>
<chapter xml:id="-introduction">
<title>Introduction</title>
<section xml:id="-the-abs-language">
<title>The ABS Language</title>
<simpara>The <emphasis role="strong">ABS language</emphasis> is an actor-based, object-oriented, executable modeling
language.  Its prime features are:</simpara>
<variablelist>
<varlistentry>
<term>Algebraic user-defined data types and side effect-free functions </term>
<listitem>
<simpara>All data
(except the state of objects and future variables) is immutable, and functions
are free of side effects.  This makes understanding and reasoning about models
easier.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>User-defined data types are used for data modeling instead of objects, so ABS
models are typically smaller than their Java counterparts.</simpara>
<variablelist>
<varlistentry>
<term>A syntax that is close to Java </term>
<listitem>
<simpara>Programmers that are used to Java can easily
learn the ABS language.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Distributed, actor-based semantics </term>
<listitem>
<simpara>Method calls are asynchronous and create
a new process in the target.  Processes are scheduled cooperatively and run
within the scope of one object.  Futures are used to synchronize with and get
the result of another process.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interfaces for specifying object behavior </term>
<listitem>
<simpara>Similar to Java, the behavior of
a class is defined by implementing zero or more interfaces with their
corresponding methods.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Safe concurrency </term>
<listitem>
<simpara>Processes run cooperatively within one object and do not
have access to other objects' state, and data structures are immutable.  The
most common error causes of concurrent systems (aliasing, insufficient
locking) are avoided by the language semantics.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Distributed computing </term>
<listitem>
<simpara>The combination of asynchronous method calls,
immutability and strong encapsulation makes it very easy to model distributed
systems.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>A formal semantics and compositional proof theory </term>
<listitem>
<simpara>ABS is designed to be
amenable to program analysis and verification.  A variety of tools (deadlock
checker, resource analysis, formal verification) have been developed.</simpara>
</listitem>
</varlistentry>
</variablelist>
<sidebar>
<title>Non-goals</title>
<simpara>Languages are eco-systems, and a language containing all possible features
will be easy to use for no one.  The following areas are currently
under-served by ABS:</simpara>
<variablelist>
<varlistentry>
<term>Parallel computing </term>
<listitem>
<simpara>Algorithms relying on multiple processes operating on
mutable state, e.g., from the domain of scientific computing, can only be
expressed in roundabout ways.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Close-to-the-metal programming </term>
<listitem>
<simpara>ABS is not designed to be a systems
programming language.</simpara>
</listitem>
</varlistentry>
</variablelist>
</sidebar>
</section>
<section xml:id="sec:concurrency-model">
<title>The ABS Actor and Concurrency Model</title>
<simpara>As mentioned, ABS method calls are asynchronous and create a new process in
the target, while the caller process continues to run in parallel, as shown in
Figure <xref linkend="fig-future-await"/>.  At point ①, P1 issues an asynchronous call to
some object residing on another cog.  In response, a new process P2 is
created; P1 and P2 can run in parallel.  At point ②, P1 needs the result of
the method call and suspends itself.  At point ③, P2 finishes and returns a
value.  P1’s cog then reactivates P1 to continue execution.</simpara>
<figure xml:id="fig-future-await">
<title>Process call semantics</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ABS-future-await.png" contentwidth="636" contentdepth="233"/>
</imageobject>
<textobject><phrase>Process call semantics</phrase></textobject>
</mediaobject>
</figure>
<simpara>The paragraph above elides some details.  An asynchronous method call (see
<xref linkend="async-call-expression"/>) produces a <emphasis>future variable</emphasis>, which is used both to
synchronize with the callee process (see <xref linkend="await-stmt"/>) and to get the result
(see <xref linkend="get-expression"/>).  Future variables are first-class objects that can
be passed along, so multiple processes can synchronize on the same future.</simpara>
<simpara>The processes created by method calls are scheduled cooperatively and run
within the scope of the target object.  Objects are grouped into COGs
(Concurrent Object Groups).  Each cog runs one process at a time, while
processes on different cogs run in parallel, as shown in Figure
<xref linkend="fig-cog-scheduling"/>.  This means that each cog is a <emphasis role="strong">unit of concurrency</emphasis>
and is in charge of scheduling the processes running on its objects.  Each
process runs until it suspends itself (see <xref linkend="await-stmt"/> and
<xref linkend="suspend-stmt"/>) or terminates, at which point the cog chooses the next
process to run.</simpara>
<figure xml:id="fig-cog-scheduling">
<title>Processes running inside their cogs</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ABS-scheduling.png" contentwidth="636" contentdepth="283"/>
</imageobject>
<textobject><phrase>Processes running inside their cogs</phrase></textobject>
</mediaobject>
</figure>
<simpara>A new cog is created by creating an object with a <literal>new</literal> expression (see Figure
<xref linkend="fig-object-new-cog"/>).</simpara>
<figure xml:id="fig-object-new-cog">
<title>Creating an object in a new cog</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/new-cog-object.png" contentwidth="565" contentdepth="151"/>
</imageobject>
<textobject><phrase>Creating an object in a new cog</phrase></textobject>
</mediaobject>
</figure>
<simpara>An object in an existing cog is created via the <literal>new local</literal> expression (see Figure
<xref linkend="fig-object-new-local"/>).</simpara>
<figure xml:id="fig-object-new-local">
<title>Creating an object in the same cog</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/new-local-object.png" contentwidth="593" contentdepth="154"/>
</imageobject>
<textobject><phrase>Creating an object in the same cog</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="sec:error-model">
<title>Error Propagation and Recovery in ABS</title>
<simpara>ABS models exceptional (unforeseen and erroneous) situations using exceptions.
This section gives an overview of the language constructs that deal with
exception propagation and recovery.</simpara>
<simpara>Exceptions occur when a process cannot continue normal execution, e.g., when
trying to divide by zero or when no pattern in a <literal>case</literal> expression matches the
given value.  Exceptions can also be thrown by the modeler via the <literal>throw</literal>
statement: <xref linkend="throw-statement"/>.  Exceptions thrown implicitly or explicitly
are propagated and handled in the same way.</simpara>
<simpara>The modeler can define new exceptions; see <xref linkend="exception-type"/>.</simpara>
<simpara>Exceptions can be caught and handled locally, i.e., in a lexically enclosing
<literal>try</literal>-<literal>catch</literal>-<literal>finally</literal> block in the same method (see <xref linkend="try-catch-finally-stmt"/>).
In that case, the process continues execution and will eventually produce a
return value to its future.</simpara>
<simpara>In case of an <emphasis>unhandled</emphasis> exception, the future of the process does not
receive a return value; instead, it will propagate the unhandled exception to
the caller (or any process that tries to get its value).  When evaluating
<literal>f.get</literal> on a future that carries an exception instead of a normal return
value, the exception will be <emphasis>re-thrown</emphasis>; it can be handled as usual via
<literal>try</literal>-<literal>catch</literal> or left to propagate up the call chain of futures.</simpara>
<simpara>Additionally, terminating a process in the middle of execution might leave its
object in an inconsistent state.  To recover from this, ABS uses <emphasis>recovery
blocks</emphasis> (see <xref linkend="sec:classes"/>).  Unhandled exceptions are handed to the
recovery block, which can take appropriate action to re-establish the class
invariant and/or send asynchronous messages to other objects.</simpara>
</section>
</chapter>
<chapter xml:id="-lexical-structure">
<title>Lexical Structure</title>
<simpara>This section describes the lexical structure of the ABS language.  We use the
following EBNF conventions for specifying the syntax of ABS elements.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>EBNF syntax for this manual</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="83*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>typewriter text</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Terminal symbols (occurring in program source code)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>CursiveText</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Non-terminals (production rule names)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>::=</simpara></entry>
<entry align="left" valign="top"><simpara>Separator between left hand side and right hand side of a rule</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>|</simpara></entry>
<entry align="left" valign="top"><simpara>Variant; either of the element(s) separated by |</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>[ ]</simpara></entry>
<entry align="left" valign="top"><simpara>Optionals; the enclosed elements can be omitted</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>{ }</simpara></entry>
<entry align="left" valign="top"><simpara>Repetition; zero or more occurrences of the enclosed elements</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>? ?</simpara></entry>
<entry align="left" valign="top"><simpara>Special group (elements in the group are specified informally)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>[: :]</simpara></entry>
<entry align="left" valign="top"><simpara>A character class, as in extended regular expression syntax</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>( )</simpara></entry>
<entry align="left" valign="top"><simpara>Grouping</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="-line-terminators-and-white-spaces">
<title>Line Terminators and White Spaces</title>
<simpara>Line terminators and white spaces are defined as in Java.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>LineTerminator</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>\n</literal> | <literal>\r</literal> | <literal>\r\n</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>WhiteSpace</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>LineTerminator</emphasis> | <literal>␣</literal> | <literal>\t</literal> | <emphasis>Comment</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="-comments">
<title>Comments</title>
<simpara>ABS supports the two common Java-style styles of comments: end-of-line comments and block comments.</simpara>
<simpara>An end-of-line comment starts with two slashes, e.g., <literal>// text</literal>. All text that follows <literal>//</literal> until the end of the line is treated as a comment.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>Comment</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>LineComment</emphasis> | <emphasis>BlockComment</emphasis><?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>LineComment</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>//</literal> { ? characters except <emphasis>LineTerminator</emphasis> ? } <emphasis>LineTerminator</emphasis><?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>BlockComment</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/*</literal> { ? characters except <literal>*/</literal> ? } <literal>*/</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>// this is a comment
module A; // this is also a comment</screen>
</para>
</formalpara>
<simpara>A block comment is enclosed in <literal>/* */</literal>,
e.g., <literal>/* this is a comment */</literal>.  Block comments can span
multiple lines and do not nest.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>/* this
is a multiline
comment */</screen>
</para>
</formalpara>
</section>
<section xml:id="-identifiers">
<title>Identifiers</title>
<simpara>Identifiers consist of a letter followed by a sequence of letters,
numbers and underscores (<literal>_</literal>).</simpara>
<simpara>ABS distinguishes identifiers and type identifiers.  Identifiers start
with a lower-case character, type identifiers start with an upper-case
character.  Identifiers name local variables, fields, methods and functions.
Type identifiers name interfaces, classes, types, type
constructors, deltas and products.</simpara>
<simpara>Identifiers can be <emphasis>qualified</emphasis> with a module name (see <xref linkend="sec:modules"/>) or
<emphasis>simple</emphasis> (without module name prefix).</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>SimpleIdentifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>[: lower :] { [: alpha :] | [: digit :] | <literal>_</literal> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>SimpleTypeIdentifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>[: upper :] { [: alpha :] | [: digit :] | <literal>_</literal> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>QualifiedIdentifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>{ <emphasis>SimpleTypeIdentifier</emphasis> <literal>.</literal> } <emphasis>SimpleIdentifier</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>QualifiedTypeIdentifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>{ <emphasis>SimpleTypeIdentifier</emphasis> <literal>.</literal> } <emphasis>SimpleTypeIdentifier</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Identifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>SimpleIdentifier</emphasis> | <emphasis>QualifiedIdentifier</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>TypeIdentifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>SimpleTypeIdentifier</emphasis> | <emphasis>QualifiedTypeIdentifier</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="-keywords">
<title>Keywords</title>
<simpara>The following words are keywords in the ABS language and are invalid as identifiers.</simpara>
<informaltable frame="all" rowsep="0" colsep="0">
<tgroup cols="7">
<colspec colname="col_1" colwidth="14*"/>
<colspec colname="col_2" colwidth="14*"/>
<colspec colname="col_3" colwidth="14*"/>
<colspec colname="col_4" colwidth="14*"/>
<colspec colname="col_5" colwidth="14*"/>
<colspec colname="col_6" colwidth="14*"/>
<colspec colname="col_7" colwidth="14*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>adds</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>after</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>assert</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>await</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>builtin</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>case</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>catch</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>class</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>core</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>data</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>def</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>delta</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>die</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>else</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>exception</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>export</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>extends</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>features</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>finally</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>get</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hasField</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>hasInterface</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>hasMethod</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>if</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>implements</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>import</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>in</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>interface</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>let</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>local</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>modifies</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>module</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>new</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>original</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>product</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>productline</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>recover</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>removes</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>return</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>skip</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>suspend</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>this</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>throw</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>trait</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>try</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>type</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>uses</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="sec:literals">
<title>Literals</title>
<simpara>A literal is a textual representation of a value. ABS supports three kinds of
literals, integer literals, string literals, and the null literal.</simpara>
<simpara>Strings are enclosed in double quotes (<literal>"</literal>).  Line feed in a string is written
as <literal>\n</literal>, carriage return as <literal>\r</literal>.</simpara>
<simpara>ABS does not support floating point numbers currently.  Rational numbers are
written using the division operator <literal>/</literal>, e.g., <literal>1/4</literal> for one quarter.</simpara>
<simpara>The null literal is written as <literal>null</literal>.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>Literal</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>IntLiteral</emphasis> | <emphasis>StringLiteral</emphasis> | <emphasis>ThisLiteral</emphasis> | <emphasis>NullLiteral</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>IntLiteral</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0</literal> | ( ( <literal>1</literal> | &#8230;&#8203; | <literal>9</literal>] ) { [: digit :] } )</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>StringLiteral</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"</literal> { ? <emphasis>Valid String Character</emphasis> ? } <literal>"</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>ThisLiteral</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>this</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>NullLiteral</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Valid string characters are defined as in the Java language.</simpara>
</section>
<section xml:id="-annotations">
<title>Annotations</title>
<simpara>Annotations consist of a syntactically valid pure expression, optionally
preceded by a type identifier (the “tag”) and a colon (<literal>:</literal>).  They can be put
in front of statements and definitions.  Annotations are enclosed in square
brackets (<literal>[]</literal>).</simpara>
<simpara>There can be more than one annotation in one place.  When annotating a place
with more than one annotation, writing the annotations in separate pairs of
brackets or separated by commas in one pair of brackets produces the same
effect.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>AnnotationFragment</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>[ <emphasis>TypeIdentifier</emphasis> <literal>:</literal> ] <emphasis>PureExp</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Annotation</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>{ <literal>[</literal> <emphasis>Annotationfragment</emphasis> { <literal>,</literal> <emphasis>AnnotationFragment</emphasis> } <literal>]</literal> }</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Annotations are used to write auxiliary information that can be used by
various tools.  Unknown (user-defined) annotations are ignored by the
tool chain.  Pre-defined annotations are usually type-checked.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>[Near] class Example { ... }</screen>
</para>
</formalpara>
<simpara>This is an example of annotations with a tag:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>[Cost: 15, Deadline: Duration(20)] o!m();</screen>
</para>
</formalpara>
<simpara>The same annotations, written in separate brackets:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>[Cost: 15] [Deadline: Duration(20)] o!m();</screen>
</para>
</formalpara>
<simpara>Annotations are associated with the following language construct.  In the
examples above, the first annotation pertains to the class definition of
<literal>Example</literal>, the second annotation pertains to the asynchronous method call
<literal>o!m()</literal>.</simpara>
<simpara>In general, it is not an error to have more than one annotation with the same
tag in the same place.  However, some pre-defined annotations might forbid
this.</simpara>
</section>
</chapter>
<chapter xml:id="-types">
<title>Types</title>
<simpara>ABS has a static, nominal type system.  Local variables, object fields,
function parameters and method parameters are statically typed.  A type name
can refer to a algebraic data type, an interface, a type synonym.  There are a
number of pre-defined data types which are documented in Chapter <xref linkend="sec:standard-library"/>.</simpara>
<simpara>A <emphasis>type name</emphasis> is a sequence of letters, digits and  underscores (<literal>_</literal>) starting
with an uppercase letter.  In case of a parametric data type, the type name
continues with a left angle (<literal>&lt;</literal>), a list of type names separated by commas
and ends with a right angle (<literal>&gt;</literal>).</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>Type</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>TypeIdentifier</emphasis> [ <literal>&lt;</literal> <emphasis>Type</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> } <literal>&gt;</literal> ]</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>New types are defined as either <emphasis>interfaces</emphasis> or <emphasis>algebraic data types</emphasis>.
Algebraic data types can be <emphasis>parametric</emphasis>, which is useful for defining
“container-like” data types.  Currently only algebraic data types can be
parameterized, i.e., ABS does not currently offer class templates.</simpara>
<simpara>Note that classes are not types in ABS.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>String <co xml:id="CO1-1"/>
A_s1mple_type <co xml:id="CO1-2"/>
Map&lt;Int, List&lt;String&gt;&gt; <co xml:id="CO1-3"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>The type name is <literal>String</literal>.  The string type is defined in the standard library.</para>
</callout>
<callout arearefs="CO1-2">
<para>This is a type name containing underscores and digits.</para>
</callout>
<callout arearefs="CO1-3">
<para>This type name denotes a map from integers to lists of strings.</para>
</callout>
</calloutlist>
<section xml:id="sec:builtin-types">
<title>Built-in Types</title>
<simpara>ABS offers the following built-in datatypes:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>ABS built-in types</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Example</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Unit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The empty (void) type</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Unit</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-unit"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Boolean values</simpara></entry>
<entry align="left" valign="top"><simpara><literal>True</literal>, <literal>False</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-bool"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Int</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Integers of arbitrary size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0</literal>, <literal>-15</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-numbers"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Rat</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rational numbers</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1/5</literal>, <literal>22/58775</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-numbers"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Strings</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"Hello world\n"</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-string"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Fut&lt;A&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Futures</simpara></entry>
<entry align="left" valign="top"><simpara>&#8201;&#8212;&#8201;</simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-future"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Exception</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Exceptions</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DivisionByZeroException</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="exception-type"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>List&lt;A&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Lists of values of type <literal>A</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list[1, 2, 3]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-list"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Set&lt;A&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets of values of type <literal>A</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>set[True, False]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-set"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Map&lt;A,B&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Maps from type <literal>A</literal> to <literal>B</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>map[Pair(1, True)]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-map"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pair&lt;A,B&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pairs of values</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Pair(1, True)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-pair"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Triple&lt;A,B,C&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Triples of values</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Triple(1, "hi", True)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-triple"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Maybe&lt;A&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional values</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Just(True)</literal>, <literal>Nothing</literal></simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="type-optionals"/></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><literal>Int</literal> type is a subtype of <literal>Rat</literal>; this means that <literal>Int</literal> values are assignable
to places of type <literal>Rat</literal>.  Rational values can be converted to integers via the
<literal>truncate</literal> function.</simpara>
<simpara>The future type <literal>Fut&lt;A&gt;</literal> is a special built-in type that denotes that an ABS
value of type <literal>A</literal> will become available in the future.  The value that a
future holds and will return can be of any concrete type.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>Fut&lt;String&gt; <co xml:id="CO2-1"/>
Fut&lt;List&lt;Rat&gt;&gt; <co xml:id="CO2-2"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>This future will contain a value of type <literal>String</literal></para>
</callout>
<callout arearefs="CO2-2">
<para>This future will contain a list of rational numbers</para>
</callout>
</calloutlist>
</section>
<section xml:id="sec:algebraic-data-types">
<title>Algebraic Data Types</title>
<simpara>Algebraic Data Types in ABS are used to implement user-defined, immutable data
values.  Because values of algebraic data types are immutable, they can be
safely passed on to other objects and cogs and make it easy to reason about
program correctness.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>DataTypeDecl</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>data</literal> <emphasis>SimpleTypeIdentifier</emphasis> [ <emphasis>TypeParams</emphasis> ] [ <literal>=</literal> <emphasis>DataConstr</emphasis> { <literal>|</literal> <emphasis>DataConstr</emphasis> } ] <literal>;</literal><?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>TypeParams</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&lt;</literal> <emphasis>SimpleTypeIdentifier</emphasis> { <literal>,</literal> <emphasis>SimpleTypeIdentifier</emphasis> } <literal>&gt;</literal><?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>DataConstr</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>SimpleTypeIdentifier</emphasis> [ <literal>(</literal> <emphasis>Type</emphasis> [ <emphasis>SimpleIdentifier</emphasis> ] { <literal>,</literal> <emphasis>Type</emphasis> [ <emphasis>SimpleIdentifier</emphasis> ] } <literal>)</literal> ]</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Data Type <emphasis>Constructors</emphasis> enumerate the possible values of a data type.
Constructors can have zero or more arguments.  Each argument can have an
optional accessor function (see <xref linkend="sec:accessor-functions"/>).</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>data IntList = NoInt | ConsInt(Int head, IntList tail); <co xml:id="CO3-1"/>
data Bool = True | False; <co xml:id="CO3-2"/>
data NotInstantiable; <co xml:id="CO3-3"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>The data type <literal>IntList</literal> has two constructors: <literal>NoInt</literal> and <literal>ConsInt</literal>.  Both define an accessor function.</para>
</callout>
<callout arearefs="CO3-2">
<para>This is the definition of the built-in data type <literal>Bool</literal>.</para>
</callout>
<callout arearefs="CO3-3">
<para>This type does not have constructors and therefore cannot be instantiated.</para>
</callout>
</calloutlist>
<section xml:id="sec:accessor-functions">
<title>Accessor Functions</title>
<simpara>Data constructor arguments can optionally have a name, which needs to be a
valid identifier.  If a name is given, it defines a function that, when passed a
value expressed with the given constructor, return the argument.</simpara>
<simpara>The name of an accessor function must be unique in the module it is
defined in.  It is an error to have a function definition with the same name as an accessor
function or to have multiple accessor functions with the same name, unless they
belong to the same data type.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>data Person = Person(String name, Int age);
{
  Person john = Person("John", 34);
  Int age = age(john); <co xml:id="CO4-1"/>
}</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO4-1">
<para>The call to <literal>age</literal> returns 34.</para>
</callout>
</calloutlist>
</section>
<section xml:id="-parametric-data-types">
<title>Parametric Data Types</title>
<simpara>Algebraic data types can carry <emphasis>type parameters</emphasis>.  Data types with type
parameters are called <emphasis>parametric data types</emphasis>.</simpara>
<simpara>Parametric Data Types are useful to define “container” data types, such as
lists, sets or maps. Parametric data types are declared like normal data types
but have an additional type parameter section inside broken brackets (<literal>&lt;</literal> <literal>&gt;</literal>)
after the data type name.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>data List&lt;A&gt; = Nil | Cons(A, List&lt;A&gt;);</screen>
</para>
</formalpara>
<simpara>When using a parametric data type, concrete types are given for the type parameters.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>List&lt;Int&gt; l = Cons(1, Cons(2, Nil));</screen>
</para>
</formalpara>
</section>
<section xml:id="sec:n_ary-constructors">
<title>N-ary Constructors</title>
<simpara>Literal values of recursive data types like lists and sets can be arbitrarily
long, and nested constructor expressions can become unwieldy.  ABS provides a
special syntax for n-ary constructors, which are transformed into constructor
expressions via a user-supplied function.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>def Set&lt;A&gt; set&lt;A&gt;(List&lt;A&gt; l) = <co xml:id="CO5-1"/>
    case l {
       Nil =&gt; EmptySet;
       Cons(x,xs) =&gt; insertElement(set(xs), x);
    };

{
  Set&lt;Int&gt; s1 = set(Cons(1, Cons(2, Cons(3, Nil)))); <co xml:id="CO5-2"/>
  Set&lt;Int&gt; s = set[1, 2, 3]; <co xml:id="CO5-3"/>
}</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para>The parametric function <literal>set</literal> is defined to take a list of elements and return a set.</para>
</callout>
<callout arearefs="CO5-2">
<para><literal>set</literal> is called with a literal list constructed as normal.</para>
</callout>
<callout arearefs="CO5-3">
<para><literal>set</literal> is called with the special n-ary constructor syntax.  The two calls return the same value.</para>
</callout>
</calloutlist>
<simpara>The constructor function usually has the same name as the type it is
constructing.  For example, a value of type <literal>Set</literal> is constructed via the
function <literal>set</literal>.</simpara>
</section>
<section xml:id="-fully-abstract-data-types">
<title>Fully Abstract Data Types</title>
<simpara>Using the module system it is possible to define abstract data types.  For an
abstract data type, only the functions that operate on them are known to the
client, but not its constructors.  This can be easily realized in ABS by
putting such a data type in its own module and by only exporting the data type
and its functions, without exporting the constructors.</simpara>
</section>
</section>
<section xml:id="-interface-types">
<title>Interface Types</title>
<simpara>Interfaces in ABS describe the functionality of objects.  Thus, Interfaces in
ABS are similar to interfaces in Java.  Unlike Java, objects are only typed by
interfaces and not by their class.</simpara>
<simpara>The syntax of interfaces is given in <xref linkend="sec:interfaces"/>.</simpara>
</section>
<section xml:id="sec:exception-types">
<title>Exceptions</title>
<simpara>In higher-level programming languages, exceptions are generally used to signal
an <emphasis>erroneous</emphasis> or <emphasis>abnormal</emphasis> runtime behavior of the program, that should be
treated (handled) separately compared to normal values.</simpara>
<simpara>Exceptions are declared with the keyword <literal>exception</literal>, followed by the name of
an exception and an optional list of parameters.  The semantics are the same
as for defining data constructors; naming a parameter will create an accessor
function (see <xref linkend="sec:accessor-functions"/>).</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ExceptionDecl</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>exception</literal> <emphasis>SimpleTypeIdentifier</emphasis>  [ ( <emphasis>Type</emphasis> [ <emphasis>SimpleIdentifier</emphasis> ] { , <emphasis>Type</emphasis> [ <emphasis>SimpleIdentifier</emphasis> ] } ) ] <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Like any other constructor or datatype name, exceptions always start with an
upper-case letter.</simpara>
<simpara>Exceptions are of type <literal>ABS.StdLib.Exception</literal>, which is pre-defined in the
standard library.  It is possible to store exception values in variables of
type <literal>Exception</literal>.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>exception MyException;
exception MyOtherException(String param, Int); // no accessor for second param</screen>
</para>
</formalpara>
<simpara>In ABS, exceptions are first-class values; the user can construct
exception-values, assign them to variables, pass them in expressions, etc.  An
exception can be thrown via the <literal>throw</literal> statement (see <xref linkend="throw-statement"/>)
and be caught in a <literal>catch</literal> block (see <xref linkend="try-catch-finally-stmt"/>).
Additionally, the object itself can recover its invariant after an uncaught
exception in a process via its recovery block (see <xref linkend="sec:classes"/>).</simpara>
</section>
<section xml:id="-type-synonyms">
<title>Type Synonyms</title>
<simpara>A <emphasis>Type Synonym</emphasis> is an alternative type name for a type.  Type synonyms are
introduced with the keyword <literal>type</literal>.  Parametric type synonyms are not
currently supported.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>TypeSynDecl</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>type</literal> <emphasis>SimpleTypeIdentifier</emphasis> <literal>=</literal> <emphasis>Type</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>type Filename = String;
type Filenames = Set&lt;Filename&gt;;
type Servername = String;
type Packet = String;
type File = List&lt;Packet&gt;;
type Catalog = List&lt;Pair&lt;Servername,Filenames&gt;&gt;;</screen>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="-expressions">
<title>Expressions</title>
<simpara>This chapter specifies all ABS expressions.  ABS expressions can either be
side effect-free (i.e., part of the <emphasis>functional sublanguage</emphasis>) or have side effects.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>Exp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>PureExp</emphasis> | <emphasis>EffExp</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The functional sublanguage of ABS is a purely-functional, side effect-free
language.  It comprises functions and operators on built-in datatypes,
user-defined algebraic datatypes, and user-defined functions defined on
datatypes.</simpara>
<simpara>Additionally, ABS contains a number of special expressions with well-defined
side effects, such as the <literal>new</literal> expression which creates a new object.
Expressions with side effects cannot be combined with other expressions, for
example as an argument to a function call.  This slight notational
inconvenience makes it easier to develop static analysis techniques and tools
for ABS.</simpara>
<section xml:id="sec:pure-expressions">
<title>Pure Expressions</title>
<simpara>Pure Expressions are side effect-free expressions.  The value of these
expressions only depends on their arguments, and they can be evaluated
multiple times without influencing the execution semantics.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>PureExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>SimpleIdentifier</emphasis><?asciidoc-br?>
 | <literal>this</literal> <literal>.</literal> <emphasis>SimpleIdentifier</emphasis><?asciidoc-br?>
 | <literal>this</literal><?asciidoc-br?>
 | <literal>null</literal><?asciidoc-br?>
 | <emphasis>Literal</emphasis><?asciidoc-br?>
 | <emphasis>LetExp</emphasis><?asciidoc-br?>
 | <emphasis>DataConstrExp</emphasis><?asciidoc-br?>
 | <emphasis>FnAppExp</emphasis><?asciidoc-br?>
 | <emphasis>FnAppListExp</emphasis><?asciidoc-br?>
 | <emphasis>ParFnAppExp</emphasis><?asciidoc-br?>
 | <emphasis>IfExp</emphasis><?asciidoc-br?>
 | <emphasis>CaseExp</emphasis><?asciidoc-br?>
 | <emphasis>OperatorExp</emphasis><?asciidoc-br?>
 | <literal>(</literal> <emphasis>PureExp</emphasis> <literal>)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="-literal-expressions">
<title>Literal Expressions</title>
<simpara>Literals, as defined in <xref linkend="sec:literals"/>, are expressions.</simpara>
</section>
<section xml:id="-operator-expressions">
<title>Operator Expressions</title>
<simpara>ABS has a range of unary and binary operators working on pre-defined
datatypes.  All operators are pure (side effect-free).</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>OperatorExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>UnaryExp</emphasis> | <emphasis>BinaryExp</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>UnaryExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>UnaryOp</emphasis> <emphasis>PureExp</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>UnaryOp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>!</literal> | <literal>-</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>BinaryExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>PureExp</emphasis> <emphasis>BinaryOp</emphasis> <emphasis>PureExp</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>BinaryOp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>||</literal> | <literal>&amp;&amp;</literal> | <literal>==</literal> | <literal>!=</literal> | <literal>&lt;</literal> | <literal>&lt;=</literal> | <literal>&gt;</literal> | <literal>&gt;=</literal> | <literal>+</literal> | <literal>-</literal> | <literal>*</literal> | <literal>/</literal> | <literal>%</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following table describes the meaning as well as the associativity and the
precedence of the different operators. The list is sorted from low precedence
to high precedence.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>ABS Operators</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Expression</entry>
<entry align="left" valign="top">Meaning</entry>
<entry align="left" valign="top">Associativity</entry>
<entry align="left" valign="top">Argument types</entry>
<entry align="left" valign="top">Result type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>e1 || e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>logical or</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 &amp;&amp; e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>logical and</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 == e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>equality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 != e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>inequality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 &lt; e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>less than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 &lt;= e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>less than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 &gt; e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>greater than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 &gt;= e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>greater than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 + e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>concatenation</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 + e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>addition</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 - e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>subtraction</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 * e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>multiplication</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 / e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>division</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Rat</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e1 % e2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>modulo</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Int</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>!e</literal></simpara></entry>
<entry align="left" valign="top"><simpara>logical negation</simpara></entry>
<entry align="left" valign="top"><simpara>right</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-e</literal></simpara></entry>
<entry align="left" valign="top"><simpara>integer negation</simpara></entry>
<entry align="left" valign="top"><simpara>right</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="-semantics-of-comparison-operators">
<title>Semantics of Comparison Operators</title>
<simpara>ABS has generic equality and less-than comparison between two values of the
same type.</simpara>
<simpara>Equality and inequality comparison is standard: by value for functional
datatypes and by reference for objects and futures.  I.e., two strings
<literal>"Hello"</literal> compare as identical via <literal>==</literal>, as do two sets containing identical
values.  Two references to objects or futures compare as identical via <literal>==</literal> if
they point to the same object or future.  The inequality operator <literal>!=</literal>
evaluates to <literal>True</literal> for any two values that compare to <literal>False</literal> under <literal>==</literal> and
vice versa.</simpara>
<simpara>For the comparison operator <literal>&lt;</literal>, an ordering is defined in the following way.</simpara>
<itemizedlist>
<listitem>
<simpara>Numbers compare as usual.</simpara>
</listitem>
<listitem>
<simpara>Strings compare lexicographically.</simpara>
</listitem>
<listitem>
<simpara>Algebraic datatypes compare first by constructor name, then by comparing
constructor arguments left to right.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example</title>
<para>
<screen>Cons(_, _) &lt; Nil
Cons(1, _) &lt; Cons(2, _)</screen>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Objects and futures are compared by identity, in an implementation-specific
but stable way.  This means that for any two variables <literal>a</literal> and <literal>b</literal> that
point to different objects, the value of <literal>a &lt; b</literal> does not change as long as
<literal>a</literal> and <literal>b</literal> are not re-assigned.<footnote><simpara>This ordering is not guaranteed to be stable between two invocations of a program.  If ABS ever develops object serialization, care must be taken to uphold any datatype invariants across program invocations, e.g., when reading back an ordered list of objects.</simpara></footnote></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="-the-let-expression">
<title>The Let Expression</title>
<simpara>The expression <literal>let (T v) = p in b</literal> evaluates <literal>b</literal>, with <literal>v</literal> bound to the value
of evaluating the expression <literal>p</literal>.  The newly-introduced binding of <literal>v</literal> can
shadow a binding of <literal>v</literal> outside of the <literal>let</literal> expression.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>LetExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>let</literal> <literal>(</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> <literal>)</literal> = <emphasis>PureExp</emphasis> <literal>in</literal> <emphasis>PureExp</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>let (Int x) = 2 + 2 in x * 2</screen>
</para>
</formalpara>
</section>
<section xml:id="-the-data-constructor-expression">
<title>The Data Constructor Expression</title>
<simpara>Data Constructor Expressions are expressions that create data values by
applying arguments to data type constructors.  Data constructor expressions
look similar to function calls, but data constructors always start with an
upper-case letter.</simpara>
<simpara>For data type constructors without parameters, the parentheses are optional.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>DataConstrExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>TypeIdentifier</emphasis> [ <literal>(</literal> [ <emphasis>PureExp</emphasis> { <literal>,</literal> <emphasis>PureExp</emphasis> } ] <literal>)</literal> ]</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>True
Cons(True, Nil)
Nil</screen>
</para>
</formalpara>
<simpara>Defining new data types and their constructors is described in
<xref linkend="sec:algebraic-data-types"/>.</simpara>
</section>
<section xml:id="-the-function-call-expression">
<title>The Function Call Expression</title>
<simpara>Function calls apply arguments to functions, producing a value.  Function call
expressions look similar to data constructor expressions, but function names
always start with a lower-case letter.  The parentheses are mandatory in
function calls.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>FnAppExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Identifier</emphasis> <literal>(</literal> [ <emphasis>PureExp</emphasis> { <literal>,</literal> <emphasis>PureExp</emphasis> } ] <literal>)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>tail(Cons(True, Nil))
head(list)</screen>
</para>
</formalpara>
<section xml:id="-the-n-ary-function-call-expression">
<title>The N-ary Function Call Expression</title>
<simpara>Calls to n-ary Constructors (see <xref linkend="sec:n_ary-constructors"/>) are written with
brackets (<literal>[]</literal>) instead of parentheses (<literal>()</literal>).</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>FnAppListExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Identifier</emphasis> <literal>[</literal> [ <emphasis>PureExp</emphasis> { <literal>,</literal> <emphasis>PureExp</emphasis> } ] <literal>]</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="-the-partially-defined-function-call-expression">
<title>The Partially-Defined-Function Call Expression</title>
<simpara>Calls to partially defined functions (see <xref linkend="sec:partially-defined-functions"/>) are similar to
function call expressions, but have an additional prepended set of arguments.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ParFnAppExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Identifier</emphasis><?asciidoc-br?>
  <literal>(</literal> [ <emphasis>ParFnAppParam</emphasis> { <literal>,</literal> <emphasis>ParFnAppParam</emphasis> } ] <literal>)</literal><?asciidoc-br?>
  <literal>(</literal> [ <emphasis>PureExp</emphasis> { <literal>,</literal> <emphasis>PureExp</emphasis> } ] <literal>)</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>ParFnAppParam</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Identifier</emphasis><?asciidoc-br?>
                  | <emphasis>AnonymousFunction</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>AnonymousFunction</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>(</literal> [ <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis>  } ]  <literal>)</literal> <literal>=></literal> <emphasis>PureExp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>map(toString)(list[1, 2])
filter((Int i) =&gt; i &gt; 0)(list[0, 1, 2])</screen>
</para>
</formalpara>
</section>
<section xml:id="-the-conditional-expression">
<title>The Conditional Expression</title>
<simpara>The value of the conditional expression <literal>if c then e1 else e2</literal> is either the
value of <literal>e1</literal> or the value of <literal>e2</literal>, depending on the value of <literal>c</literal>, which must
be of type <literal>Bool</literal>.  Depending on the value of <literal>c</literal>, either <literal>e1</literal> or <literal>e2</literal> is
evaluated, but not both.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>IfExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>if</literal> <emphasis>PureExp</emphasis> <literal>then</literal> <emphasis>PureExp</emphasis> <literal>else</literal> <emphasis>PureExp</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>if 5 == 4 then True else False</screen>
</para>
</formalpara>
</section>
<section xml:id="case-expression">
<title>Case Expressions</title>
<simpara>ABS supports pattern matching via the Case Expression.  A case expression
consists of an input expression and a series of branches, each consisting of a
pattern and a right hand side expression.</simpara>
<simpara>The case expression evaluates its input expression and attempts to match the
resulting value against the branches until a matching pattern is found.  The
value of the case expression itself is the value of the expression on the
right-hand side of the first matching pattern.</simpara>
<simpara>If no pattern matches the expression, a <literal>PatternMatchFailException</literal> is thrown.</simpara>
<simpara>There are four different kinds of patterns available in ABS:</simpara>
<itemizedlist>
<listitem>
<simpara>Variables (with different semantics depending on whether the variable is bound or not)</simpara>
</listitem>
<listitem>
<simpara>Literal Patterns (e.g., <literal>5</literal>)</simpara>
</listitem>
<listitem>
<simpara>Data Constructor Patterns (e.g., <literal>Cons(Nil,x)</literal>)</simpara>
</listitem>
<listitem>
<simpara>Underscore Pattern (<literal>_</literal>)</simpara>
</listitem>
</itemizedlist>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>CaseExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>case</literal> <emphasis>PureExp</emphasis> <literal>{</literal> { <emphasis>CaseExpBranch</emphasis> } <literal>}</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>CaseExpBranch</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Pattern</emphasis> <literal>=&gt;</literal> <emphasis>PureExp</emphasis> <literal>;</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Pattern</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_</literal><?asciidoc-br?>
                 | <emphasis>SimpleIdentifier</emphasis><?asciidoc-br?>
                 | <emphasis>Literal</emphasis><?asciidoc-br?>
                 | <emphasis>ConstrPattern</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>ConstrPattern</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>TypeIdentifier</emphasis> [ <literal>(</literal> [ <emphasis>Pattern</emphasis> { <literal>,</literal> <emphasis>Pattern</emphasis> }  ] <literal>)</literal> ]</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="-the-variable-pattern">
<title>The Variable Pattern</title>
<simpara>Variable patterns are written as identifiers starting with a lower-case
letter.  If the identifier does not name a variable in the current scope, the
variable pattern matches any value and introduces a binding of the given
identifier to the matched value for the right-hand side of the branch and the
rest of the pattern itself.  In case a binding for that identifier is already
in scope, its value is compared to the value being matched against.</simpara>
<simpara>The variable being named by the variable pattern can be used in the
right-hand-side expression of the corresponding branch.  Typically, pattern
variables are used inside of data constructor patterns to extract values from
data constructors.  For example:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>let (Pair&lt;Int, Int&gt; a) = Pair(5, 5) in
  case a {
    Pair(x, x) =&gt; x; <co xml:id="CO6-1"/>
    Pair(x, y) =&gt; y; <co xml:id="CO6-2"/>
  } <co xml:id="CO6-3"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO6-1">
<para>This branch matches a pair with identical values.</para>
</callout>
<callout arearefs="CO6-2">
<para>This branch matches every pair.  Since pairs with identical values are matched by the previous branch, <literal>x</literal> and <literal>y</literal> will be different.</para>
</callout>
<callout arearefs="CO6-3">
<para>The value of the whole expression is 5, produced by the first branch.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example</title>
<para>
<screen>let (x = 7) in
  case Pair(5, 5) {
    Pair(x, x) =&gt; x; <co xml:id="CO7-1"/>
    Pair(x, y) =&gt; y; <co xml:id="CO7-2"/>
    Pair(y, z) =&gt; z; <co xml:id="CO7-3"/>
  } <co xml:id="CO7-4"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO7-1">
<para>This pattern does not match since <literal>x</literal> is bound to 7 and does not match 5.</para>
</callout>
<callout arearefs="CO7-2">
<para>This pattern does not match either, for the same reason.</para>
</callout>
<callout arearefs="CO7-3">
<para>This pattern contains only unbound variable patterns and therefore matches.</para>
</callout>
<callout arearefs="CO7-4">
<para>The value of the whole expression is 5, produced by the third branch.</para>
</callout>
</calloutlist>
</section>
<section xml:id="-the-literal-pattern">
<title>The Literal Pattern</title>
<simpara>Literals can be used as patterns.  The pattern matches if the value of the
case expression is equal to the literal value.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>let (Pair&lt;Int, Int&gt; a) = Pair(5, 5) in
  case a {
    Pair(3, x) =&gt; x; <co xml:id="CO8-1"/>
    Pair(x, y) =&gt; y; <co xml:id="CO8-2"/>
  } <co xml:id="CO8-3"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO8-1">
<para>The pattern <literal>3</literal> does not match the value in the first position of the <literal>Pair</literal> constructor pattern.</para>
</callout>
<callout arearefs="CO8-2">
<para>This pattern matches.</para>
</callout>
<callout arearefs="CO8-3">
<para>The value of the whole expression is 5, produced by the second branch.</para>
</callout>
</calloutlist>
</section>
<section xml:id="-the-data-constructor-pattern">
<title>The Data Constructor Pattern</title>
<simpara>A data constructor pattern is written like a standard data constructor expression.
Constructor arguments are again patterns.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>let (List&lt;Int&gt; l) = list[1, 2, 3] in
  case l {
    Nil =&gt; 0; <co xml:id="CO9-1"/>
    Cons(1, _) =&gt; 15; <co xml:id="CO9-2"/>
    Cons(_, Cons(y, _)) =&gt; y; <co xml:id="CO9-3"/>
  } <co xml:id="CO9-4"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para>This pattern matches the empty list.</para>
</callout>
<callout arearefs="CO9-2">
<para>This pattern matches a list starting with the literal <literal>1</literal>.</para>
</callout>
<callout arearefs="CO9-3">
<para>This pattern matches a list of at least length 2, and binds the second element to <literal>y</literal>.</para>
</callout>
<callout arearefs="CO9-4">
<para>The value of the whole expression is 15, produced by the second branch.</para>
</callout>
</calloutlist>
</section>
<section xml:id="-the-wildcard-pattern">
<title>The Wildcard Pattern</title>
<simpara>The wildcard pattern, written with an underscore (<literal>_</literal>) matches any value.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>let (List&lt;Int&gt; l) = list[1, 2, 3] in
  case l {
    Nil =&gt; True; <co xml:id="CO10-1"/>
    _ =&gt; False; <co xml:id="CO10-2"/>
}; <co xml:id="CO10-3"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO10-1">
<para>This pattern matches the empty list.</para>
</callout>
<callout arearefs="CO10-2">
<para>This pattern matches anything.</para>
</callout>
<callout arearefs="CO10-3">
<para>The value of the whole expression is <literal>False</literal>, produced by the second branch.</para>
</callout>
</calloutlist>
<simpara>The wildcard pattern can be used as the last pattern in a case expression to
define a default case.</simpara>
<formalpara>
<title>Typing of Case Expressions</title>
<para>A case expression is type-correct if and only if all its expressions and all
its branches are type-correct and the right-hand side of all branches have a
common super type.  This common super type is also the type of the overall case
expression.  A branch (a pattern and its expression) is type-correct if its
pattern and its right-hand side expression are type-correct.  A pattern is
type-correct if it can match the corresponding case expression.</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="sec:side-effect-expressions">
<title>Expressions with Side Effects</title>
<simpara>ABS has expressions with side effects.  These expressions are only legal
“stand-alone”, i.e., not as a sub-expression of another expression.  This
means that sub-expressions of expressions can only be pure expressions.  This
restriction simplifies the reasoning about expressions in the ABS modeling
language.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>EffExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>NewExp</emphasis><?asciidoc-br?>
                 | <emphasis>SyncCall</emphasis><?asciidoc-br?>
                 | <emphasis>AsyncCall</emphasis><?asciidoc-br?>
                 | <emphasis>GetExp</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="-new-expression">
<title>New Expression</title>
<simpara>A <literal>new</literal> expression creates a new object from a class name and a list of
arguments.  In ABS objects can be created in two different ways.  Either they
are created in the current COG, using the <literal>new local</literal> expression, or they are
created in a new COG by using the <literal>new</literal> expression (see
<xref linkend="sec:concurrency-model"/> for more details about cogs).</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>NewExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>new</literal> [ <literal>local</literal> ] <emphasis>TypeIdentifier</emphasis> <literal>(</literal> [ <emphasis>PureExp</emphasis> {<literal>,</literal> <emphasis>PureExp</emphasis> } ] <literal>)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>new local Foo(5)
new Bar()</screen>
</para>
</formalpara>
<simpara>Classes can declare an <emphasis>init block</emphasis> (see <xref linkend="sec:classes"/>), which is executed for
each new instance.  The semantics of the <literal>new</literal> expression guarantee that the
init block is fully executed before the new object begins receiving method
calls.  Classes can also declare a <literal>run</literal> method, which is automatically
invoked after the init block and subject to the normal scheduling rules for
processes.</simpara>
</section>
<section xml:id="-synchronous-call-expression">
<title>Synchronous Call Expression</title>
<simpara>A synchronous call consists of a target expression evaluating to an interface
type, a method name declared in that interface, and a list of argument expressions.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>SyncCall</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>PureExp</emphasis> <literal>.</literal> <emphasis>SimpleIdentifier</emphasis> <literal>(</literal> <emphasis>PureExp</emphasis> { <literal>,</literal> <emphasis>PureExp</emphasis> } <literal>)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>Bool b = x.m(5, 3);</screen>
</para>
</formalpara>
<simpara>The semantics of the synchronous method call differ depending on whether the
caller and callee are in the same cog.  A synchronous method call between
objects in the same cog has Java-like semantics, i.e., the caller is suspended
and the called method starts executing immediately.  When the called method
finishes, the caller process is scheduled and resumes execution.</simpara>
<simpara>In the case when caller and called object are in different cogs, a synchronous
method call is equivalent to and asynchronous method call immediately followed
by a <literal>get</literal> expression on the resulting future.  This means that the intuitive
semantics of synchronous method calls are preserved, but introduces the
possibility of deadlocks in case the callee tries to call back to an object of
the caller cog.</simpara>
</section>
<section xml:id="async-call-expression">
<title>Asynchronous Call Expression</title>
<simpara>An asynchronous call consists of a target expression evaluating to an
interface type, a method name declared in that interface, and a list of
argument expressions.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>AsyncCall</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>PureExp</emphasis> <literal>!</literal> <emphasis>SimpleIdentifier</emphasis> <literal>(</literal> <emphasis>PureExp</emphasis> { <literal>,</literal> <emphasis>PureExp</emphasis> }  <literal>)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>An asynchronous method call creates a new task in the COG that contains the
target.  This means that the caller task proceeds independently and in
parallel with the callee task, without waiting for the result.  The result of
evaluating an asynchronous method call expression <literal>o!m(e)</literal> is a <emphasis>future</emphasis> of
type (<literal>Fut&lt;V&gt;</literal>), where <literal>V</literal> is the return type of the callee method <literal>m</literal>.</simpara>
<simpara>This future is resolved (i.e., it gets a value) when the callee task finishes.
It can be used to synchronize with the callee task and obtain the result of
the method call.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>Fut&lt;Bool&gt; f = x!m(5);</screen>
</para>
</formalpara>
</section>
<section xml:id="get-expression">
<title>Get Expression</title>
<simpara>A get expression is used to obtain the value from a future.  The current task
is blocked until the future has been resolved, i.e., until either the return
value is available or an exception has occurred in the callee task.  No other
task in the COG can be activated while the current task is blocked by a get
expression.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>GetExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>PureExp</emphasis> <literal>.</literal> <literal>get</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>Bool b = f.get;</screen>
</para>
</formalpara>
<simpara>If the future contains a normal return value, the value of the get expression
is that value.  If the future contains an exception thrown by the callee
process, evaluating the get expression will throw the same exception.  The
value thrown by a get expression can be caught by try-catch as normal (see
<xref linkend="try-catch-finally-stmt"/>).</simpara>
<simpara>The following example assigns the return value contained in <literal>f</literal> to the
variable <literal>b</literal>.  In case of any error, <literal>b</literal> is assigned <literal>False</literal>.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>try b = f.get; catch { _ =&gt; b = False; }</screen>
</para>
</formalpara>
</section>
<section xml:id="await-expression">
<title>Await Expression</title>
<simpara>An await expression is a way to asynchronously call a method, wait for the
callee to finish, and get the result in one expression.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>AwaitExp</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>await</literal> <emphasis>AsyncCall</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>A x = await o!m();</screen>
</para>
</formalpara>
<simpara>The statement above is equivalent to the three statements in the following example.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>Fut&lt;A&gt; fx = o!m();
await fx?;
A x = fx.get;</screen>
</para>
</formalpara>
</section>
</section>
</chapter>
<chapter xml:id="-function-definitions">
<title>Function Definitions</title>
<simpara>Functions take a list of arguments and evaluate the expression in their body,
producing a return value.  ABS functions are always pure.  This means the body
of a function can use all pure expressions (see <xref linkend="sec:pure-expressions"/>) but
no expressions with side effects (see <xref linkend="sec:side-effect-expressions"/>).</simpara>
<simpara>Functions can be <emphasis>parametric</emphasis>, which means that they can take and return
parametric datatypes.  This means that a function <literal>head</literal> defined over a
parametric list datatype can return the first element of a list, regardless of
its type.  Parametric functions are defined like normal functions but have an
additional type parameter section inside angle brackets (<literal>&lt;</literal> <literal>&gt;</literal>) after the
function name.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>FunctionDecl</emphasis>  ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>def</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> [ <literal>&lt;</literal> <emphasis>SimpleTypeIdentifier</emphasis> { <literal>,</literal> <emphasis>SimpleTypeIdentifier</emphasis> } <literal>&gt;</literal> ]<?asciidoc-br?>
                        <literal>(</literal> [ <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis>  } ]  <literal>)</literal><?asciidoc-br?>
                        <literal>=</literal> <emphasis>PureExp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>def Rat abs(Rat x) = if x &gt; 0 then x else -x; <co xml:id="CO11-1"/>

def Int length&lt;A&gt;(List&lt;A&gt; list) = <co xml:id="CO11-2"/>
case list {
  Nil =&gt; 0;
  Cons(_, ls) =&gt; 1 + length(ls);
};

def A head&lt;A&gt;(List&lt;A&gt; list) = <co xml:id="CO11-3"/>
  case list { Cons(x, _) =&gt; x; };</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO11-1">
<para>The <literal>abs</literal> function returns the absolute value of its argument.</para>
</callout>
<callout arearefs="CO11-2">
<para>This parametric function takes lists with arbitrary values and returns an Integer.</para>
</callout>
<callout arearefs="CO11-3">
<para>This parametric function returns the same type that is contained in the list.  (Note that <literal>head</literal> is a partial function which is not defined for empty lists.)</para>
</callout>
</calloutlist>
<note>
<simpara>The ABS standard library contains some special functions that cannot be
defined with pure expressions, for example the function <literal>println</literal>.  Each
special function has to be implemented in each backend.  The details of
implementing special functions are outside of the scope of this manual.</simpara>
</note>
<section xml:id="sec:partially-defined-functions">
<title>Partial Function Definitions</title>
<simpara>For reasons of simplicity and analyzability, ABS does not offer higher-order
functions.  On the other hand, many common patterns of functional programming
are extremely useful, for example the well-known <literal>map</literal>, <literal>filter</literal> and <literal>fold</literal>
higher-order functions.  For this reason, ABS supports <emphasis>partial function
definitions</emphasis>.</simpara>
<simpara>Partial function definitions are function definitions taking an additional set
of parameters.  These additional parameters can be either names of normal
functions, or anonymous functions (see <xref linkend="sec:anonymous-functions"/>).  Partial
function definitions define a set of functions which only differ in function
applications but share overall structure.  Put another way, partial function
definitions define second-order functions&#8201;&#8212;&#8201;functions that take first-order
functions as arguments.  Partially defined functions can be used inside
functional code, but cannot be passed as parameters to other partial
functions.</simpara>
<simpara>A partially defined function is called the same way as a normal function, with
a separate argument list containing the functional arguments.  For recursion
inside the body of a partially defined function, omit the function parameter
list.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>PartialFunctionDecl</emphasis>  ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>def</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> [ <literal>&lt;</literal> <emphasis>SimpleTypeIdentifier</emphasis> { <literal>,</literal> <emphasis>SimpleTypeIdentifier</emphasis> } <literal>&gt;</literal> ]<?asciidoc-br?>
                        <literal>(</literal> [ <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>SimpleIdentifier</emphasis>  } ]  <literal>)</literal><?asciidoc-br?>
                        <literal>(</literal> [ <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis>  } ]  <literal>)</literal><?asciidoc-br?>
                        <literal>=</literal> <emphasis>PureExp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>// Simply applies a function fn to a value.
def B apply&lt;A, B&gt;(fn)(A value) = fn(a);

def Int double(Int x) = x * 2;

{
  // doubled = 4
  Int doubled = apply(double)(2);
}</screen>
</para>
</formalpara>
<formalpara>
<title>Example</title>
<para>
<screen>def List&lt;B&gt; map&lt;A, B&gt;(f)(List&lt;A&gt; list) = case list { <co xml:id="CO12-1"/>
    Nil =&gt; Nil;
    Cons(x, xs) =&gt; Cons(f(x), map(xs)); <co xml:id="CO12-2"/>
};

def Int double(Int x) = x * 2;

{
  // doubled = [2, 4, 6]
  List&lt;Int&gt; doubled = map(double)(list[1, 2, 3]);
}</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>This definition of <literal>map</literal> is contained in the standard library.</para>
</callout>
<callout arearefs="CO12-2">
<para>Note the recursive call to <literal>map</literal> omits the function parameter list.</para>
</callout>
</calloutlist>
<note>
<simpara>For each call of a partial function, a normal function definition is
generated at compile time by replacing the functional parameters syntactically
by the functions passed in the additional parameter list.  This is done before
type checking and after delta and trait flattening&#8201;&#8212;&#8201;any type mismatch and
similar errors are caught afterwards during type checking.  If multiple
statements call a partially defined function with the same function-name
arguments, only one expansion is generated.</simpara>
</note>
</section>
<section xml:id="sec:anonymous-functions">
<title>Anonymous Functions</title>
<simpara>To reduce the need to declare a function with a new function name explicitly
every time a partially defined function is called, ABS uses anonymous
functions.  Anonymous functions are only allowed in the first arguments list
calls to partially defined functions.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>AnonymousFunction</emphasis>  ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>(</literal> [ <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis>  } ]  <literal>)</literal> <literal>&#8658;</literal> <emphasis>PureExp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>An anonymous function specifies a number of parameters and an expression that
may refer to the declared parameters.</simpara>
<simpara>The following example is equivalent to the previous example, but does not
define the <literal>double</literal> function explicitly.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>{
  List&lt;Int&gt; list = list[1, 2, 3];
  list = map((Int y) =&gt; y * 2)(list);
}</screen>
</para>
</formalpara>
<simpara>Anonymous functions can refer to variables and fields accessible in the
context of the partial function call.  (Since anonymous functions are not
first-class values, no closure is created.)</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>{
  Int factor = 5;
  List&lt;Int&gt; list = list[1, 2, 3];
  list = map((Int y) =&gt; y * factor)(list);
  // list = [5, 10, 15]
}</screen>
</para>
</formalpara>
<note>
<simpara>Anonymous functions are inlined into the expansion of the partial
function definition.  Errors caused by wrong typing are caught after the
expansion during the type checking of core ABS, but the expanded function
definition has an annotation referring to the statement that caused the
expansion, hence error reporting will be accurate wrt. the original source
code.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="-statements">
<title>Statements</title>
<simpara>This chapter specifies all ABS statements.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>Statement</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>SkipStmt</emphasis><?asciidoc-br?>
| <emphasis>VarDeclStmt</emphasis><?asciidoc-br?>
| <emphasis>AssignStmt</emphasis><?asciidoc-br?>
| <emphasis>ExpStmt</emphasis><?asciidoc-br?>
| <emphasis>AssertStmt</emphasis><?asciidoc-br?>
| <emphasis>AwaitStmt</emphasis><?asciidoc-br?>
| <emphasis>SuspendStmt</emphasis><?asciidoc-br?>
| <emphasis>ThrowStmt</emphasis><?asciidoc-br?>
| <emphasis>ReturnStmt</emphasis><?asciidoc-br?>
| <emphasis>Block</emphasis><?asciidoc-br?>
| <emphasis>IfStmt</emphasis><?asciidoc-br?>
| <emphasis>CaseStmt</emphasis><?asciidoc-br?>
| <emphasis>WhileStmt</emphasis><?asciidoc-br?>
| <emphasis>ForeachStmt</emphasis><?asciidoc-br?>
| <emphasis>TryCatchFinallyStmt</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="-skip">
<title>Skip</title>
<simpara>The skip statement is a statement that does nothing.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>SkipStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>skip</literal> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>skip;</screen>
</para>
</formalpara>
</section>
<section xml:id="-variable-declarations">
<title>Variable Declarations</title>
<simpara>A variable declaration statement is used to declare variables.  Variable
declarations can occur at any point in a sequence of statements; i.e., it is
not necessary to declare variables only at the beginning of methods or blocks.</simpara>
<simpara>Variables declared inside a block are in scope for the duration of the block.
It is an error to declare a variable with the same name of another variable in
scope.  A local variable can have the same name as an object field.</simpara>
<simpara>A variable declaration has an expression that defines the initial value of the
variable.  The initialization expression is mandatory except for variables of
reference types (interfaces and futures), in which case the variable is
initialized with <literal>null</literal> if the initialization expression is omitted.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>VarDeclStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> [ <literal>=</literal> <emphasis>Exp</emphasis> ] <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>Bool b = True;</screen>
</para>
</formalpara>
<section xml:id="-constant-declarations">
<title>Constant Declarations</title>
<simpara>Variable and field declarations can carry a <literal>Final</literal> annotation.  the effect of
such an annotation is to forbid re-assignment to such variables.</simpara>
<simpara>The following example will lead to a compile-time error since we are trying to
assign a new value to <literal>constant_i</literal>:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>{
    [Final] Int constant_i = 24;
    constant_i = 25;
}</screen>
</para>
</formalpara>
</section>
</section>
<section xml:id="-assignment">
<title>Assignment</title>
<simpara>The assign statement assigns a value to a variable or a field.</simpara>
<simpara>Assignments to a field <literal>f</literal> can be written either <literal>this.f = e;</literal> or <literal>f = e;</literal>.
In case a local variable <literal>f</literal> is in scope at the point of the assignment
statement, the <literal>this</literal> prefix has to be used to assign to the field <literal>f</literal>; assignment
to <literal>f</literal> will change the value of the local variable.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>AssignStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>[ <literal>this</literal> <literal>.</literal> ] <emphasis>SimpleIdentifier</emphasis> <literal>=</literal> <emphasis>Exp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>this.f = True;
x = 5;</screen>
</para>
</formalpara>
</section>
<section xml:id="-expressions-as-statements">
<title>Expressions as Statements</title>
<simpara>An expression statement is a statement that consists of a single expression.
When an expression statement is executed, the expression is evaluated and the
resulting value is discarded.</simpara>
<simpara>Expression statements are used for their side effects, for example issuing an
asynchronous method call without waiting for its result.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ExpStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Exp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Creating an object without storing a reference (and hence never invoking
a method on the new object) can be a meaningful operation, for example when
the object has a <literal>run</literal> method and interacts with the rest of the system by
calling methods on references passed in via the <literal>new</literal> expression.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<screen>server!operate();
new Client(server);</screen>
</para>
</formalpara>
</section>
<section xml:id="-assertions">
<title>Assertions</title>
<simpara>An assert statement is a statement for asserting certain conditions.  If the
expression evaluates to <literal>True</literal>, executing an assertion is equivalent to
<literal>skip;</literal>.  If the expression evaluates to <literal>False</literal>, it is equivalent to <literal>throw
AssertionFailException;</literal>.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>AssertStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>assert</literal> <emphasis>PureExp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>assert x != null;</screen>
</para>
</formalpara>
</section>
<section xml:id="await-stmt">
<title>Await Statement</title>
<simpara>An await statement suspends the current task until the given guard becomes
active (evaluates to <literal>True</literal>).  While the task is suspended, other tasks within
the same COG can be scheduled.</simpara>
<simpara>Guards can wait for a futures to become resolved, for a Boolean condition over
the object state to become true, or (in timed ABS) for a certain duration to
pass.</simpara>
<simpara>In general, each cog will continue running a task without preempting it until
the task is finished or it reaches a <emphasis>scheduling point</emphasis>.  Await statements are
scheduling points, as are <literal>suspend</literal> statements and assignment or expression
statements containing an await expression (see <xref linkend="await-expression"/>).</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>AwaitStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>await</literal> <emphasis>Guard</emphasis> <literal>;</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Guard</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>[ <literal>this</literal> <literal>.</literal> ] <emphasis>SimpleIdentifier</emphasis> <literal>?</literal><?asciidoc-br?>
| <emphasis>PureExp</emphasis><?asciidoc-br?>
| <emphasis>Guard</emphasis> <literal>&amp;</literal> <emphasis>Guard</emphasis><?asciidoc-br?>
| <literal>duration</literal> <literal>(</literal> <emphasis>PureExp</emphasis> <literal>,</literal> <emphasis>PureExp</emphasis> <literal>)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>Fut&lt;Bool&gt; f = x!m();
await f?; <co xml:id="CO13-1"/>
await this.x == True; <co xml:id="CO13-2"/>
await f? &amp; this.y &gt; 5; <co xml:id="CO13-3"/>
await duration(3, 5); <co xml:id="CO13-4"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO13-1">
<para>A <emphasis>claim guard</emphasis> becomes active when the future is resolved (contains a value or an exception).</para>
</callout>
<callout arearefs="CO13-2">
<para>A <emphasis>field guard</emphasis> is a Boolean expression over the object state.</para>
</callout>
<callout arearefs="CO13-3">
<para>A <emphasis>guard conjunction</emphasis> becomes active when both its components are active.</para>
</callout>
<callout arearefs="CO13-4">
<para>A <emphasis>duration guard</emphasis> becomes active after a certain amount of simulated time has passed.  See <xref linkend="sec:timed-abs"/> for more on timed models.</para>
</callout>
</calloutlist>
</section>
<section xml:id="suspend-stmt">
<title>Unconditional Release: Suspend</title>
<simpara>The suspend statement causes the current task to be suspended.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>SuspendStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>suspend</literal> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>There is no guarantee that the cog will choose another task to run; the
current task might be resumed immediately after suspending itself.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<screen>suspend;</screen>
</para>
</formalpara>
</section>
<section xml:id="-return">
<title>Return</title>
<simpara>A return statement returns a value from a method.  A return statement can only
appear as a last statement in a method body.</simpara>
<simpara>For asynchronous method calls, executing the return statement will cause the
future to be resolved so that it contains a value.  Any claim guards awaiting
the future will become active.</simpara>
<simpara>Methods that have a <literal>Unit</literal> return type do not need an explicit return
statement.  The future will be resolved when the method terminates.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ReturnStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>return</literal> <emphasis>Exp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>ABS does not allow exiting a method from multiple points, e.g., via
multiple <literal>return</literal> statements.  This makes model analysis easier.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<screen>return x;</screen>
</para>
</formalpara>
</section>
<section xml:id="throw-statement">
<title>Throw</title>
<simpara>The statement <literal>throw</literal> signals an exception (see <xref linkend="sec:exception-types"/>).  It
takes a single argument of type <literal>ABS.StdLib.Exception</literal>, which is the exception
value to throw.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ThrowStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>throw</literal> <emphasis>PureExp</emphasis> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>  throw AssertionFailException;</screen>
</para>
</formalpara>
<simpara>Note that the 'throw' statement can only be used inside imperative code.
Functional code that cannot return a value in all cases should use the <literal>Maybe</literal>
datatype.</simpara>
<screen>def Maybe&lt;Int&gt; f(Int x, Int y) = if (y &lt; 0) then None else Just(x);</screen>
<simpara>Furthermore, note that some built-in exceptions, like
<literal>DivisionByZeroException</literal> and <literal>PatternMatchFailException</literal> can originate from
functional code.  See <xref linkend="stdlib:predefined-exceptions"/> for a list of built-in
exceptions.</simpara>
</section>
<section xml:id="-blocks-of-statements">
<title>Blocks of Statements</title>
<simpara>A sequence of statements is called a <emphasis>block</emphasis>.  A block introduces a scope for
local variables.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>Block</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>{</literal> { <emphasis>Statement</emphasis> } <literal>}</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Semantically, a whole block is a single statement and can be written
anywhere a single statement is valid.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<screen>{
  Int a = 0; <co xml:id="CO14-1"/>
  a = a + 1;
  n = a % 10;
}

{ } <co xml:id="CO14-2"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO14-1">
<para>The variable <literal>a</literal> is in scope until the end of the block.</para>
</callout>
<callout arearefs="CO14-2">
<para>An empty block is equivalent to <literal>skip;</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="-conditionals">
<title>Conditionals</title>
<simpara>ABS has the standard conditional statement.  The condition has to evaluate to
a Boolean value.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>IfStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>if</literal> <literal>(</literal> <emphasis>PureExp</emphasis> <literal>)</literal> <emphasis>Stmt</emphasis> [ <literal>else</literal> <emphasis>Stmt</emphasis> ]</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>if (5 &lt; x) {
  y = 6;
}
else {
  y = 7;
}
if (True)
  x = 5;</screen>
</para>
</formalpara>
</section>
<section xml:id="case-stmt">
<title>Case: Pattern Matching</title>
<simpara>The case statement, like the case expression (see <xref linkend="case-expression"/>),
consists of an expression and a series of branches, each consisting of a
pattern and a statement (which can be a block).</simpara>
<simpara>When a case statement is executed, its input expression is evaluated and the
value matched against the branches until a matching pattern is found.  The
statement in the right-hand side of that branch is then executed.  Any
variable bindings introduced by matching the pattern are in effect while
executing that statement.</simpara>
<simpara>If no pattern matches the expression, a <literal>PatternMatchFailException</literal> is thrown.</simpara>
<simpara>For a description of the pattern syntax, see <xref linkend="case-expression"/>.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>CaseStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>case</literal> <emphasis>PureExp</emphasis> <literal>{</literal> { <emphasis>CaseStmtBranch</emphasis> } <literal>}</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>CaseStmtBranch</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Pattern</emphasis> <literal>=&gt;</literal> <emphasis>Stmt</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>Pair&lt;Int, Int&gt; p = Pair(2, 3);
Int x = 0;
case p {
  Pair(2, y) =&gt; { x = y; skip; }
  _ =&gt; x = -1;
}</screen>
</para>
</formalpara>
</section>
<section xml:id="-the-while-loop">
<title>The While Loop</title>
<simpara>The while loop repeats its body while the condition evaluates to <literal>True</literal>.  The
condition is re-evaluated after each iteration of the loop.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>WhileStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>while</literal> <literal>(</literal> <emphasis>PureExp</emphasis> <literal>)</literal> <emphasis>Stmt</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>while (x &lt; 5) {
  x = x + 1;
}</screen>
</para>
</formalpara>
</section>
<section xml:id="-the-foreach-loop">
<title>The Foreach Loop</title>
<simpara>The foreach loop repeatedly executes its body with the loop variable bound to
each element of the given list, in sequence.  The rules for the loop variable
follow the rules of local variable declarations in blocks: the loop variable
cannot shadow an existing variable, but can use the same name as an object
field.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ForeachStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>foreach</literal> <literal>(</literal> <emphasis>Identifier</emphasis> <literal>in</literal> <emphasis>PureExp</emphasis> <literal>)</literal> <emphasis>Stmt</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<screen>foreach (i in list[1, 2, 3]) {
  println("i = " + toString(i));
}</screen>
</para>
</formalpara>
</section>
<section xml:id="try-catch-finally-stmt">
<title>Handling Exceptions with Try-Catch-Finally</title>
<simpara>Executing a statement can result in an exception, either explicitly signaled
using the <literal>throw</literal> keyword or implicitly, for example by dividing by zero.  The
try-catch-finally statement is used to handle exceptions and resume normal
execution afterwards.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>TryCatchFinallyStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>try</literal> <emphasis>Stmt</emphasis><?asciidoc-br?>
                              <literal>catch</literal> ( <literal>{</literal> { <emphasis>CaseStmtBranch</emphasis> } <literal>}</literal>  | <emphasis>CaseStmtBranch</emphasis> )<?asciidoc-br?>
                              [ <literal>finally</literal> <emphasis>Stmt</emphasis> ]</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The statement protected by <literal>try</literal> (which can be a block) is executed first.  If
no exception is thrown, execution continues with the optional <literal>finally</literal>
statement, then with the next statement after the try-catch-finally statement.</simpara>
<simpara>If during execution of the statement protected by <literal>try</literal> an exception is
thrown, it is matched one-by-one against the exception patterns defined in the
<literal>catch</literal> block.  The statement following the first matching pattern will be
executed, as in the case statement (see <xref linkend="case-stmt"/>).  Execution continues
with the optional <literal>finally</literal> statement, then with the statement following the
try-catch-finally statement.</simpara>
<simpara>If during execution of the statement protected by <literal>try</literal> an exception is thrown
that is not matched by any branch in the <literal>catch</literal> block, the exception is
<emphasis>unhandled</emphasis>.  In this case, first the optional <literal>finally</literal> statement is
executed.  If the try-catch-finally was protected by another try-catch-finally
statement, the unhandled exception is passed on to this surrounding
try-catch-finally statement.  Otherwise, the current process terminates and
its future is resolved by storing the unhandled exception.  Any <literal>get</literal>
expression on this future will re-throw the exception (see
<xref linkend="get-expression"/>).  The object that ran the aborted process will execute its
recovery block with the unhandled exception as parameter (see
<xref linkend="sec:classes"/>).</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>try {
    Rat z = 1/x; <co xml:id="CO15-1"/>
} catch {
    DivisionByZeroException =&gt; println("We divided by zero"); <co xml:id="CO15-2"/>
} finally {
    println("Leaving the protected area"); <co xml:id="CO15-3"/>
}</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO15-1">
<para>If <literal>x</literal> is zero, this will throw an exception</para>
</callout>
<callout arearefs="CO15-2">
<para>Division by zero is handled here; other exceptions will be left unhandled</para>
</callout>
<callout arearefs="CO15-3">
<para>This statement is always executed</para>
</callout>
</calloutlist>
<simpara>As a syntactic convenience, when matching only a single pattern, the braces
around the catch block can be omitted.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>try b = f.get; catch _ =&gt; b = False; <co xml:id="CO16-1"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO16-1">
<para>A “catch-all” exception handler that sets <literal>b</literal> to a default value in case an unhandled exception was propagated via <literal>f</literal></para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>finally</literal> block has the same restrictions as the class init and
recovery blocks, i.e., it cannot contain processor release points (i.e.,
<literal>await</literal> or <literal>suspend</literal>), blocking expressions (i.e., <literal>get</literal>), or explicitly throw
an exception via the <literal>throw</literal> statement.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="sec:interfaces">
<title>Interfaces</title>
<simpara>Interfaces in ABS are similar to interfaces in Java.  They have a name, which
defines a nominal type, and they can extend zero or more other
interfaces.  The interface body consists of a list of method signature
declarations.  Method names start with a lowercase letter.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>InterfaceDecl</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>interface</literal> <emphasis>SimpleTypeIdentifier</emphasis> [ <literal>extends</literal> <emphasis>InterfaceList</emphasis> ] <literal>{</literal> { <emphasis>MethSig</emphasis> } <literal>}</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>InterfaceList</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>TypeIdentifier</emphasis> { <literal>,</literal> <emphasis>TypeIdentifier</emphasis> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>MethSig</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> <literal>(</literal> [ <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> } ] <literal>)</literal> <literal>;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Method declarations can carry an <literal>[Atomic]</literal> annotation.  The compiler will
statically check that any definitions for such methods do not contain
suspension points (<literal>suspend</literal> and <literal>await</literal> statements).</simpara>
<simpara>The interfaces in the example below represent a database system, providing
functionality to store and retrieve files, and a node of a peer-to-peer file
sharing system.  Each node of a peer-to-peer system plays both the role of a
server and a client.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>interface DB {
  File getFile(Filename fId);
  Int getLength(Filename fId);
  Unit storeFile(Filename fId, File file);
  Filenames listFiles();
}
interface Client {
  List&lt;Pair&lt;Server,Filenames&gt;&gt; availFiles(List&lt;Server&gt; sList);

  Unit reqFile(Server sId, Filename fId);
}
interface Server {
  Filenames inquire();
  Int getLength(Filename fId);
  Packet getPack(Filename fId, Int pNbr);
}
interface Peer extends Client, Server {
  List&lt;Server&gt; getNeighbors();
}</screen>
</para>
</formalpara>
</chapter>
<chapter xml:id="sec:classes">
<title>Classes</title>
<simpara>Classes in ABS are used to create objects via the <literal>new</literal> expression.  Classes
can implement an arbitrary number of interfaces.  Since classes are not types
in ABS, classes typically implement one or more interfaces.</simpara>
<simpara>Classes in ABS have zero or more <emphasis>class parameters</emphasis>.  Each class parameter
defines a field of the class which is assigned a value via arguments the <literal>new</literal>
expression.</simpara>
<simpara>Classes have an optional init block, which is executed before any other code.
The init block cannot contain processor release points (i.e., <literal>await</literal> or
<literal>suspend</literal>), blocking expressions (i.e., <literal>get</literal>), or explicitly throw an
exception via the <literal>throw</literal> statement.</simpara>
<simpara>Classes have an optional recovery block.  In case an uncaught exception occurs
in a method, the exception is matched against the patterns given in the
recovery block, and the associated statement(s) are executed.  If the
exception does not match any pattern in the recovery block, or if the recovery
block itself raises an exception, the object is killed.  Code in the recovery
block has the same restrictions as in the init block.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ClassDecl</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>class</literal> <emphasis>SimpleTypeIdentifier</emphasis> [ <literal>(</literal> [ <emphasis>ClassParameterList</emphasis> ] <literal>)</literal> ] [ <literal>implements</literal> <emphasis>InterfaceList</emphasis> ]<?asciidoc-br?>
                    <literal>{</literal> [ <emphasis>FieldDeclList</emphasis> ] [ <emphasis>Block</emphasis> ] [<emphasis>RecoveryBlock</emphasis>] [ <emphasis>TraitUseList</emphasis> ] { <emphasis>MethDecl</emphasis> } <literal>}</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>ClassParameterList</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>InterfaceList</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>TypeIdentifier</emphasis> { <literal>,</literal> <emphasis>TypeIdentifier</emphasis> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>TraitUseList</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>adds <emphasis>TraitName</emphasis> <literal>;</literal> {  adds <emphasis>TraitName</emphasis> <literal>;</literal>}</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>FieldDeclList</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>{ <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> [ <literal>=</literal> <emphasis>PureExp</emphasis> ] <literal>;</literal> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>RecoveryBlock</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>recover</literal> <literal>{</literal> { <emphasis>Pattern</emphasis> <literal>=&gt;</literal> <emphasis>Stmt</emphasis> } <literal>}</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>MethDecl</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> <literal>(</literal> [ <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> { <literal>,</literal> <emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis> } ] <literal>)</literal> <emphasis>Block</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>A class definition contains zero or more method definitions.  Each method has
a name, return type and zero or more parameters.  All methods declared in an
interface that is implemented by the class or one of their super-interfaces
must be defined in the class body or in one of its traits.  A class is free to
define methods not declared in an interface; such methods are private to the
class and cannot be called from outside the class.</simpara>
<note>
<simpara>ABS currently does not support method overloading.  Each method must
have a unique name since methods are not disambiguated by their parameter
lists.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<screen>class DataBase(Map&lt;Filename,File&gt; db) implements DB {
	File getFile(Filename fId) {
		return lookup(db, fId);
	}

	Int getLength(Filename fId){
		return length(lookup(db, fId));
	}

	Unit storeFile(Filename fId, File file) {
		db = insert(Pair(fId,file), db);
	}

	Filenames listFiles() {
		return keys(db);
	}

	}

class Node(DB db, Peer admin, Filename file) implements Peer {

	Catalog catalog;
	List&lt;Server&gt; myNeighbors;
	// implementation...

}</screen>
</para>
</formalpara>
<section xml:id="-atomic-methods">
<title>Atomic Methods</title>
<simpara>Definitions for atomic method declarations have to be annotated with
<literal>[Atomic]</literal> as well.  The compiler will statically check that the definition
does not contain suspension points (<literal>suspend</literal> and <literal>await</literal> statements) and
blocking <literal>get</literal> expressions.  Such methods can be called inside init blocks and
in <literal>finally</literal> clauses; all other methods cannot be called in these places.</simpara>
<simpara>The following example shows a call to an atomic method from an init block.
Removing the <literal>Atomic</literal> annotation from method <literal>m</literal> would lead to a compile-time
error.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>class Sample {
    Int field = 12;

    {
        field = this.m();
    }

    [Atomic] Int m() {
        return 24;
    }
}</screen>
</para>
</formalpara>
</section>
<section xml:id="-constant-fields">
<title>Constant Fields</title>
<simpara>Similar to variable declarations, field declarations can carry a <literal>Final</literal>
annotation.  the effect of such an annotation is to forbid re-assignment to
such a field.</simpara>
<simpara>The following example will lead to a compile-time error since we are trying to
assign a new value to <literal>constant_i</literal>:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>class Sample {
    [Final] Int constant_i = 24;
    Unit m() {
        constant_i = 25;
    }
}</screen>
</para>
</formalpara>
</section>
<section xml:id="-active-classes">
<title>Active Classes</title>
<simpara>A class can be active or passive. Active classes start an activity on their own upon creation. Passive classes only react to incoming method calls. A class is active if and only if it has a run method:</simpara>
<screen>Unit run() {
	// active behavior ...
}</screen>
<simpara>The run method is called after object initialization.</simpara>
</section>
</chapter>
<chapter xml:id="sec:traits">
<title>Traits</title>
<simpara>ABS does not support inheritance for code reuse.  Method implementations that
are common between classes can be defined once and used inside these classes by
using <emphasis>traits</emphasis>.  A trait can add, remove and modify methods of a class or of
another trait.</simpara>
<simpara>Traits are applied to classes at compile-time and do not change the
interface(s) of a class.  Classes and their methods are type-checked once all
traits are applied.</simpara>
<simpara>Similar to classes, traits in ABS are not types.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>TraitDecl</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>trait</literal> <emphasis>TraitName</emphasis> = ( <literal>{</literal> { <emphasis>MethDecl</emphasis> } <literal>}</literal> | <emphasis>TraitName</emphasis> ) { <emphasis>TraitOper</emphasis> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>TraitName</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>SimpleIdentifier</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>TraitOper</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>adds</literal> <emphasis>TraitExpr</emphasis><?asciidoc-br?>
| <literal>modifies</literal> <emphasis>TraitExpr</emphasis><?asciidoc-br?>
| <literal>removes</literal> <emphasis>MethSig</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>A trait is defined with <literal>trait</literal> t = <emphasis>T</emphasis> at module level.</simpara>
<simpara>The effect of applying a trait <emphasis>T</emphasis> to a class (using <literal>uses</literal> <emphasis>T</emphasis> inside the
class body) is to add the methods in that trait to the class
definition.</simpara>
<itemizedlist>
<title>Explanation</title>
<listitem>
<simpara>The operation <literal>adds</literal> adds all the elements of the next <emphasis>MethodSet</emphasis> to the class.
If a method with the same name is already present in the class (or set of methods), the error will be raised <emphasis>after</emphasis> applying all traits, during type checking.</simpara>
</listitem>
</itemizedlist>
<screen>trait T = { Unit x(){ skip; } }
trait T2 = { Unit y(){ skip; } } adds T</screen>
<simpara>will be resolved to the set</simpara>
<screen>{ Unit x(){ skip; } Unit y(){ skip; } }</screen>
<itemizedlist>
<listitem>
<simpara>The operation <literal>modifies</literal> changes all the elements of the next <emphasis>MethodSet</emphasis> in the class to the new implementation described in this <emphasis>MethodSet</emphasis>.
A trait may contain original() calls which refer to the version of the method before the trait application.
If a method with the same name is not present in the class (or set of methods), the method is added instead and the original() calls are not resolved.</simpara>
</listitem>
</itemizedlist>
<simpara>A method may contain targeted original calls. These raise an error if the trait is used directly by a class
The following is invalid:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>trait T = {Unit myMethod(){ skip; }}  modifies {Unit myMethod(){ core.original(); }}
class C {uses T; }</screen>
</para>
</formalpara>
<simpara>The following two examples are valid:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>trait T = {Unit myMethod(){ skip; }} modifies {Unit myMethod(){ original(); }}
class C {uses T; }</screen>
</para>
</formalpara>
<formalpara>
<title>Example</title>
<para>
<screen>module M;
trait T = {Unit myMethod(){ skip; }}
class C {uses T; }

delta D;
modifies class M.C{
        modifies Unit myMethod(){ core.original(); }
}</screen>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>The operation <literal>removes</literal> deletes the method with the provided signature.
If a method with the same name is not present in the class (or set of methods), an error will be raised during trait application.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>The order of trait application is as follows:</title>
<listitem>
<simpara>All traits used within a class, in the order they are referred to</simpara>
</listitem>
<listitem>
<simpara>All traits used within a delta, in the order they are referred to</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example</title>
<para>
<screen>module M;
interface I { Unit x(); Unit foo(); Unit bar(); }
trait T = Unit x() { this.foo(); original(); this.bar();  }
trait T2 = { Unit x() { println("T2"); } } modifies T
trait T3 = { Unit x() { println("T3"); } } modifies T
class C implements I {
        Int i = 0;
        uses T2;
        Unit foo(){ i = i+1; }
        Unit bar(){ i = i-1; }
}

class C2 implements I {
        Int i = 0;
        uses T3;
        Unit foo(){ i = i-1; }
        Unit bar(){ i = i+1; }
}</screen>
</para>
</formalpara>
</chapter>
<chapter xml:id="sec:modules">
<title>Modules</title>
<simpara>All ABS definitions (classes, interfaces, functions data types, type aliases)
are contained in modules.  All definitions are visible in their own module
only, except when the module exports the name and it is imported in another
module or referenced by its qualified name.</simpara>
<note>
<simpara>The <literal>export</literal> clause in a module definition exports <emphasis>names</emphasis>, not
definitions as such.  This means that if a module defines a class and an
interface with the same name, both definitions will be accessible if that name
is contained in the <literal>export</literal> clause.</simpara>
</note>
<section xml:id="-defining-a-module">
<title>Defining a Module</title>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>ModuleDecl</emphasis>  ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>module</literal> <emphasis>TypeIdentifier</emphasis> <literal>;</literal> { <emphasis>Export</emphasis> } { <emphasis>Import</emphasis> } { <emphasis>Decl</emphasis> } [ <emphasis>Block</emphasis> ]</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Export</emphasis>      ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>export</literal> <emphasis>IdentifierList</emphasis> [ <literal>from</literal> <emphasis>TypeIdentifier</emphasis> ] <literal>;</literal><?asciidoc-br?>
                 | <literal>export</literal> <literal>*</literal> [ <literal>from</literal> <emphasis>TypeIdentifier</emphasis> ] <literal>;</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Import</emphasis>      ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>import</literal> <emphasis>IdentifierList</emphasis> [ <literal>from</literal> <emphasis>TypeIdentifier</emphasis> ] <literal>;</literal><?asciidoc-br?>
                 | <literal>import</literal> <literal>*</literal> <literal>from</literal> <emphasis>TypeIdentifier</emphasis> <literal>;</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>IdentifierList</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>AnyIdentifier</emphasis> { <literal>,</literal> <emphasis>AnyIdentifier</emphasis> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>AnyIdentifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Identifier</emphasis> | <emphasis>TypeIdentifier</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Decl</emphasis>        ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>FunDecl</emphasis><?asciidoc-br?>
| <emphasis>TypeSynDecl</emphasis><?asciidoc-br?>
| <emphasis>DataTypeDecl</emphasis><?asciidoc-br?>
| <emphasis>ExceptionDecl</emphasis><?asciidoc-br?>
| <emphasis>InterfaceDecl</emphasis><?asciidoc-br?>
| <emphasis>ClassDecl</emphasis><?asciidoc-br?>
| <emphasis>TraitDecl</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>A module name is a type name and must always start with an upper case letter.</simpara>
<simpara>Every module starts with a declaration of the form</simpara>
<literallayout class="monospaced">module MyModule;</literallayout>
<simpara>This declaration starts a new module named <literal>MyModule</literal>.  All declarations after
this line until the next module declaration belong to the module <literal>MyModule</literal>.</simpara>
<note>
<simpara>The module <literal>ABS.StdLib</literal> contains the standard library and is
automatically imported by every module.  There is no need for an explicit
<literal>import * from ABS.StdLib;</literal> clause.</simpara>
</note>
</section>
<section xml:id="-exporting-identifiers">
<title>Exporting Identifiers</title>
<simpara>By default, modules do not export any names.  In order to make names defined
within a module available to other modules, the names have to be <emphasis>exported</emphasis>.
For example, to export a data type and a data constructor, one can write
something like this:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>module Drinks;
export Drink, pourMilk, pourWater;
data Drink = Milk | Water;
def Drink pourMilk() = Milk;
def Drink pourWater() = Water;</screen>
</para>
</formalpara>
<simpara>Note that in this example, the data constructors are not exported, and other
modules can only create values of type <literal>Drink</literal> by calling the exported
constructor functions <literal>pourMilk</literal> and <literal>pourWater</literal>.  By only exporting the data
type without any of its constructors, one can realize <emphasis>abstract data types</emphasis>
in ABS.</simpara>
<simpara>A special export clause <literal>export *;</literal> exports all names that are defined in the
module.  Note that imported names are <emphasis>not</emphasis> re-exported by <literal>export *;</literal> (but
can be re-exported via <literal>export * from OtherModule;</literal> clauses).</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>module Test;
export *;
export * from OtherModule;
import * from OtherModule;</screen>
</para>
</formalpara>
</section>
<section xml:id="-importing-identifiers">
<title>Importing Identifiers</title>
<simpara>In order to use exported names of a module in another module, the names have
to be imported.  In a module definition, a list of import clauses follows the
list of export clauses.  After being imported, these names are accessible in
the current module.</simpara>
<simpara>Names can be accessible either qualified (with package prefix) or unqualified,
depending on how they are imported.</simpara>
<simpara>The following example makes the <literal>Drink</literal> data type of the module <literal>Drinks</literal>
accessible as <literal>Drinks.Drink</literal>:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>module Bar;
import Drinks.Drink; <co xml:id="CO17-1"/>
import pourMilk from Drinks; <co xml:id="CO17-2"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>The name <literal>Drink</literal> is accessible in module <literal>Bar</literal> as <literal>Drinks.Drink</literal>.</para>
</callout>
<callout arearefs="CO17-2">
<para>The name <literal>pourMilk</literal> is accessible in module <literal>Bar</literal> both as <literal>Drinks.pourMilk</literal> and <literal>pourMilk</literal>.</para>
</callout>
</calloutlist>
<simpara>The <literal>import * from Module;</literal> statement makes all names that are exported from
module <literal>Module</literal> accessible without module qualifier in the current module.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>module Bar;
import * from Drinks; <co xml:id="CO18-1"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO18-1">
<para>All names from <literal>Drinks</literal> are accessible in <literal>Bar</literal> with and without the <literal>Drinks.</literal> prefix.</para>
</callout>
</calloutlist>
<section xml:id="-re-exporting-imported-names">
<title>Re-exporting Imported Names</title>
<simpara>It is possible to re-export names that are imported from another module. For example,</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>module Bar;
export * from Drinks;
import * from Drinks;</screen>
</para>
</formalpara>
<simpara>re-exports from <literal>Bar</literal> all names that are exported by module <literal>Drinks</literal>.  Another
module that writes <literal>import * from Bar;</literal> will have the names from <literal>Drinks</literal>
accessible as well.</simpara>
<simpara>To re-export only selected names, include only these names in the export list:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>module Bar;
export Drink; <co xml:id="CO19-1"/>
import * from Drinks;</screen>
</para>
</formalpara>
<simpara>Only <literal>Drink</literal> is exported from <literal>Bar</literal>.</simpara>
<simpara>Note that only names that have been imported can be re-exported.  For example:</simpara>
<screen>module Bar;
export * from Drinks;
import Drink from Drinks;</screen>
<simpara>only re-exports <literal>Drink</literal>, as this is the only name imported from module
<literal>Drinks</literal>.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="sec:standard-library">
<title>The Standard Library</title>
<simpara>This chapter documents the ABS standard library.  All definitions, except
where noted otherwise, are contained in the module <literal>ABS.StdLib</literal> which is
included by default in every module.  Therefore, no <literal>import</literal> statement is
necessary to use these definitions.</simpara>
<section xml:id="type-bool">
<title>Boolean values</title>
<section xml:id="-datatypes-and-constructors">
<title>Datatypes and Constructors</title>
<simpara>The literals for Boolean values are <literal>True</literal> and <literal>False</literal>.  The name of the
datatype is <literal>Bool</literal>.</simpara>
<screen>Bool value = True;</screen>
</section>
<section xml:id="-operators">
<title>Operators</title>
<simpara>The following operators apply to Boolean values:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Expression</entry>
<entry align="left" valign="top">Meaning</entry>
<entry align="left" valign="top">Associativity</entry>
<entry align="left" valign="top">Argument types</entry>
<entry align="left" valign="top">Result type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>e1 || e2</simpara></entry>
<entry align="left" valign="top"><simpara>logical or</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>Bool, Bool</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &amp;&amp; e2</simpara></entry>
<entry align="left" valign="top"><simpara>logical and</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>Bool, Bool</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 == e2</simpara></entry>
<entry align="left" valign="top"><simpara>equality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 != e2</simpara></entry>
<entry align="left" valign="top"><simpara>inequality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &lt; e2</simpara></entry>
<entry align="left" valign="top"><simpara>less than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &lt; = e2</simpara></entry>
<entry align="left" valign="top"><simpara>less than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &gt; e2</simpara></entry>
<entry align="left" valign="top"><simpara>greater than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &gt;= e2</simpara></entry>
<entry align="left" valign="top"><simpara>greater than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>! e</simpara></entry>
<entry align="left" valign="top"><simpara>logical negation</simpara></entry>
<entry align="left" valign="top"><simpara>right</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>~ e</simpara></entry>
<entry align="left" valign="top"><simpara>logical negation (deprecated)</simpara></entry>
<entry align="left" valign="top"><simpara>right</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="type-numbers">
<title>Numbers</title>
<section xml:id="-datatypes-and-constructors-2">
<title>Datatypes and constructors</title>
<simpara>The two numeric datatypes are <literal>Int</literal> and <literal>Rat</literal>.  See <xref linkend="sec:builtin-types"/> for
their syntax.</simpara>
</section>
<section xml:id="-operators-2">
<title>Operators</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Expression</entry>
<entry align="left" valign="top">Meaning</entry>
<entry align="left" valign="top">Associativity</entry>
<entry align="left" valign="top">Argument types</entry>
<entry align="left" valign="top">Result type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>e1 == e2</simpara></entry>
<entry align="left" valign="top"><simpara>equality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 != e2</simpara></entry>
<entry align="left" valign="top"><simpara>inequality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &lt; e2</simpara></entry>
<entry align="left" valign="top"><simpara>less than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &lt; = e2</simpara></entry>
<entry align="left" valign="top"><simpara>less than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &gt; e2</simpara></entry>
<entry align="left" valign="top"><simpara>greater than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &gt;= e2</simpara></entry>
<entry align="left" valign="top"><simpara>greater than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 + e2</simpara></entry>
<entry align="left" valign="top"><simpara>addition</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number, number</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 - e2</simpara></entry>
<entry align="left" valign="top"><simpara>subtraction</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number, number</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 * e2</simpara></entry>
<entry align="left" valign="top"><simpara>multiplication</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number, number</simpara></entry>
<entry align="left" valign="top"><simpara>number</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 / e2</simpara></entry>
<entry align="left" valign="top"><simpara>division</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number, number</simpara></entry>
<entry align="left" valign="top"><simpara>Rat</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 % e2</simpara></entry>
<entry align="left" valign="top"><simpara>modulo</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>number, number</simpara></entry>
<entry align="left" valign="top"><simpara>Int</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="-functions">
<title>Functions</title>
<formalpara>
<title>min, max</title>
<para>These functions calculate the maximum and minimum of their two arguments.
Since ABS datatypes are ordered, they can be applied to arguments of all
types.</para>
</formalpara>
<screen>A max&lt;A&gt;(A a, A b)
A min&lt;A&gt;(A a, A b)</screen>
<formalpara>
<title>abs</title>
<para>This function calculates the absolute (positive) value of its argument.</para>
</formalpara>
<screen>Rat abs(Rat x)</screen>
<formalpara>
<title>truncate</title>
<para>Converts a rational number to an integer by truncating towards zero.</para>
</formalpara>
<screen>Int truncate(Rat a)</screen>
<formalpara>
<title>numerator</title>
<para>Returns the numerator of a rational number, or the number itself for an
integer.</para>
</formalpara>
<screen>Int numerator(Rat a)</screen>
<formalpara>
<title>denominator</title>
<para>Returns the denominator of a rational number, or <literal>1</literal> for an integer.</para>
</formalpara>
<screen>Int denominator(Rat a)</screen>
<formalpara>
<title>pow</title>
<para>This function calculates <literal>b</literal> to the power of <literal>n</literal>.</para>
</formalpara>
<screen>Rat pow(Rat b, Int n)</screen>
<formalpara>
<title>sqrt_newton</title>
<para>This function approximates the square root of <literal>x</literal>; it stops when two subsequent
estimates (as per Newton&#8217;s algorithm) differ by less than <literal>epsilon</literal>.  <literal>estimate</literal> is an initial estimate of the
square root.</para>
</formalpara>
<screen>Rat sqrt_newton(Rat x, Rat estimate, Rat epsilon)</screen>
<formalpara>
<title>exp_newton</title>
<para>This function approximates <emphasis>e</emphasis> to the power of <literal>x</literal>; it stops when two subsequent
estimates (as per Newton&#8217;s algorithm) differ by less than <literal>epsilon</literal>.</para>
</formalpara>
<screen>Rat exp_newton(Rat x, Rat epsilon)</screen>
<formalpara>
<title>random</title>
<para>Returns an integer between 0 (inclusive) and its argument (exclusive).</para>
</formalpara>
<screen>Int random(Int below)</screen>
</section>
</section>
<section xml:id="type-string">
<title>Strings</title>
<section xml:id="-datatypes-and-constructors-3">
<title>Datatypes and Constructors</title>
<simpara>The datatype for strings is <literal>String</literal>.</simpara>
<simpara>String literals are enclosed in double quotes (<literal>"</literal>).  Line feed in a string
literal is written as <literal>\n</literal>, carriage return as <literal>\r</literal>.</simpara>
</section>
<section xml:id="-operators-3">
<title>Operators</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Expression</entry>
<entry align="left" valign="top">Meaning</entry>
<entry align="left" valign="top">Associativity</entry>
<entry align="left" valign="top">Argument types</entry>
<entry align="left" valign="top">Result type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>e1 == e2</simpara></entry>
<entry align="left" valign="top"><simpara>equality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 != e2</simpara></entry>
<entry align="left" valign="top"><simpara>inequality</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &lt; e2</simpara></entry>
<entry align="left" valign="top"><simpara>less than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &lt; = e2</simpara></entry>
<entry align="left" valign="top"><simpara>less than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &gt; e2</simpara></entry>
<entry align="left" valign="top"><simpara>greater than</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 &gt;= e2</simpara></entry>
<entry align="left" valign="top"><simpara>greater than or equal to</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>compatible</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e1 + e2</simpara></entry>
<entry align="left" valign="top"><simpara>concatenation</simpara></entry>
<entry align="left" valign="top"><simpara>left</simpara></entry>
<entry align="left" valign="top"><simpara>String, String</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="-functions-2">
<title>Functions</title>
<formalpara>
<title>toString</title>
<para>This function converts any data into a printable string representation.</para>
</formalpara>
<screen>def String toString&lt;T&gt;(T t)</screen>
<formalpara>
<title>substr</title>
<para>Returns a substring of a given string <literal>str</literal> with length <literal>length</literal> starting from
position <literal>start</literal> (inclusive).  The first character in a string has position 0.</para>
</formalpara>
<screen>def String substr(String str, Int start, Int length)</screen>
<formalpara>
<title>strlen</title>
<para>Returns the length of the given string <literal>str</literal>.  The empty string (<literal>""</literal>) has
length 0.</para>
</formalpara>
<screen>def Int strlen(String str)</screen>
<formalpara>
<title>println</title>
<para>Prints the given string <literal>s</literal> to standard output, followed by a newline, meaning
that the next output will not continue on the same line.</para>
</formalpara>
<screen>def Unit println(String s)</screen>
<formalpara>
<title>print</title>
<para>Prints the given string <literal>s</literal> to standard output.  Does not cause the next
output to begin on a new line.</para>
</formalpara>
<screen>def Unit print(String s)</screen>
</section>
</section>
<section xml:id="type-unit">
<title>Unit</title>
<simpara>Unit is the empty (void) datatype.</simpara>
<section xml:id="-datatypes-and-constructors-4">
<title>Datatypes and Constructors</title>
<simpara>Both the datatype and the single constructor are named <literal>Unit</literal>.</simpara>
</section>
</section>
<section xml:id="type-future">
<title>The Future Type</title>
<simpara>Futures are placeholders for return values of asynchronous methods calls.</simpara>
<simpara>Future values are produced by asynchronous method calls (see
<xref linkend="async-call-expression"/>).  The current process can suspend itself until a
future is resolved, i.e., until the return value of the asynchronous method
call is available (see <xref linkend="await-stmt"/>).  The get expression returns the value
of a future (see <xref linkend="get-expression"/>).  In case the future is not yet resolved,
the get expression blocks the current cog.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>Fut&lt;Int&gt; f = o!add(2, 3); <co xml:id="CO19-2"/>
await f?; <co xml:id="CO19-3"/>
Int result = f.get; <co xml:id="CO19-4"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO19-1 CO19-2">
<para>This statement defines a future variable <literal>f</literal> to hold the integer result of the method call to <literal>add</literal>.</para>
</callout>
<callout arearefs="CO19-3">
<para>The <literal>await</literal> statement suspends the current process until <literal>f</literal> is resolved.</para>
</callout>
<callout arearefs="CO19-4">
<para>The <literal>get</literal> expression returns the value computed by the <literal>add</literal> call.</para>
</callout>
</calloutlist>
<simpara>Futures are first-class values that can be stored and passed around.  In case
only the return value of the method call is needed and not the future itself,
a shorthand can be used that combines the above three statements:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>Int result = await o!add(2, 3); <co xml:id="CO20-1"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO20-1">
<para>This statement invokes <literal>add</literal>, suspends the current process until the result is available, then stores it in <literal>result</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="stdlib:predefined-exceptions">
<title>Predefined exceptions in the Standard Library</title>
<simpara>ABS provides pre-defined exceptions that are thrown in specific circumstances.
See <xref linkend="sec:exception-types"/> for information about exceptions.</simpara>
<note>
<simpara>This list is subject to revision in future versions of ABS.  Not all
these exceptions are currently thrown by different backends in the described
situation.</simpara>
</note>
<variablelist>
<varlistentry>
<term>DivisionByZeroException</term>
<listitem>
<simpara>Raised in arithmetic expressions when the divisor (denominator) is equal to 0, as in 3/0</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>AssertionFailException</term>
<listitem>
<simpara>The assert keyword was called with False as argument</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PatternMatchFailException</term>
<listitem>
<simpara>The pattern matching was not complete. In other words all c catch-all clause</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NullPointerException</term>
<listitem>
<simpara>A method was called on <literal>null</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StackOverflowException</term>
<listitem>
<simpara>The calling stack has reached its limit (system error)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HeapOverflowException</term>
<listitem>
<simpara>The memory heap is full (system error)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>KeyboardInterruptException</term>
<listitem>
<simpara>The user pressed a key sequence to interrupt the running ABS program</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ObjectDeadException</term>
<listitem>
<simpara>A method was called on a dead (crashed) object</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="type-list">
<title>Lists</title>
<simpara>A list is a sequence of values of the same type.  Lists are constructed via
the <literal>list</literal> constructor function, e.g., <literal>list[1, 2, 3]</literal> creates a list of three
integers.  An empty list is created via <literal>list[]</literal> or <literal>Nil</literal>.</simpara>
<simpara>The time to access a value via <literal>nth</literal> is proportional to the length of the
list.  The first value of a list can be accessed in constant time, using the
<literal>head</literal> function.</simpara>
<section xml:id="-datatypes-and-constructors-5">
<title>Datatypes and Constructors</title>
<simpara>A list is defined either as the empty list (<literal>Nil</literal>) or as a value <literal>a</literal> followed
by another list <literal>l</literal> (<literal>Cons(a, l)</literal>).</simpara>
<screen>data List&lt;A&gt; = Nil | Cons(A head, List&lt;A&gt; tail);</screen>
<simpara>Literal lists of arbitrary length can be written using a special function
<literal>list</literal>.  In the following example, <literal>l1</literal> and <literal>l2</literal> contain the same elements.</simpara>
<screen>List&lt;Int&gt; l1 = list[1, 2, 3];
List&lt;Int&gt; l2 = Cons(1, Cons(2, Cons(3, Nil)));</screen>
</section>
<section xml:id="-functions-3">
<title>Functions</title>
<formalpara>
<title>head</title>
<para>Returns the head of a list.</para>
</formalpara>
<screen>def A head(List&lt;A&gt; l);</screen>
<formalpara>
<title>tail</title>
<para>Returns the tail (rest) of a list.</para>
</formalpara>
<screen>def List&lt;A&gt; tail(List&lt;A&gt; l);</screen>
<formalpara>
<title>length</title>
<para>Returns the length of a list.  The length of <literal>Nil</literal> is 0.</para>
</formalpara>
<screen>def Int length(List&lt;A&gt; l);</screen>
<formalpara>
<title>isEmpty</title>
<para>Checks if a list is empty.  Returns <literal>True</literal> for <literal>Nil</literal>, <literal>False</literal> otherwise.</para>
</formalpara>
<screen>def Bool isEmpty(List&lt;A&gt; l);</screen>
<formalpara>
<title>nth</title>
<para>Returns the <literal>n</literal>-th element of a list.  Returns the head of <literal>l</literal> for <literal>n</literal>=0,
returns the last element of <literal>l</literal> for <literal>n</literal>=<literal>length(l)-1</literal>.</para>
</formalpara>
<simpara>It is an error if <literal>n</literal> is equal to or larger than <literal>length(l)</literal>.</simpara>
<screen>def A nth(List&lt;A&gt; l, Int n);</screen>
<formalpara>
<title>without</title>
<para>Returns a fresh list where all occurrences of <literal>a</literal> have been removed.</para>
</formalpara>
<screen>def List&lt;A&gt; without&lt;A&gt;(List&lt;A&gt; list, A a);</screen>
<formalpara>
<title>concatenate</title>
<para>Returns a list containing all elements of list <literal>list1</literal> followed by all
elements of list <literal>list2</literal>.</para>
</formalpara>
<screen>def List&lt;A&gt; concatenate&lt;A&gt;(List&lt;A&gt; list1, List&lt;A&gt; list2);</screen>
<formalpara>
<title>appendright</title>
<para>Returns a list containing all elements of list <literal>l</literal> followed by the element <literal>p</literal>
in the last position.</para>
</formalpara>
<screen>def List&lt;A&gt; appendright&lt;A&gt;(List&lt;A&gt; l, A p);</screen>
<formalpara>
<title>reverse</title>
<para>Returns a list containing all elements of <literal>l</literal> in reverse order.</para>
</formalpara>
<screen>def List&lt;A&gt; reverse&lt;A&gt;(List&lt;A&gt; l);</screen>
<formalpara>
<title>copy</title>
<para>Returns a list of length <literal>n</literal> containing <literal>p</literal> n times.</para>
</formalpara>
<screen>def List&lt;A&gt; copy&lt;A&gt;(A p, Int n);</screen>
<formalpara>
<title>map</title>
<para>Applies a function to each element of a list, returning a list of results in
the same order.  The function <literal>fn</literal> must take an argument of type <literal>A</literal> and
return a value of type <literal>B</literal>.</para>
</formalpara>
<screen>def List&lt;B&gt; map&lt;A, B&gt;(fn)(List&lt;A&gt; l);</screen>
<formalpara>
<title>filter</title>
<para>Returns a list containing only the elements in the given list for which the
given predicate returns <literal>True</literal>.  The function <literal>predicate</literal> must take an
argument of type <literal>T</literal> and return a Boolean value.</para>
</formalpara>
<screen>def List&lt;T&gt; filter&lt;T&gt;(predicate)(List&lt;T&gt; l);</screen>
<formalpara>
<title>foldl</title>
<para>Accumulates a value starting with <literal>init</literal> and applying <literal>accumulate</literal> from left
to right to current accumulator value and each element.  The function
<literal>accumulate</literal> must take two arguments: the first of type <literal>A</literal> (the type of the
list) and the second of type <literal>B</literal> (the accumulator and result type), and return
a value of type <literal>B</literal>.</para>
</formalpara>
<screen>def B foldl&lt;A, B&gt;(accumulate)(List&lt;A&gt; l, B init);</screen>
<formalpara>
<title>foldr</title>
<para>Accumulates a value starting with <literal>init</literal> and applying <literal>accumulate</literal> from right
to left to each element and current accumulator value.  The function
<literal>accumulate</literal> must take two arguments: the first of type <literal>A</literal> (the type of the
list) and the second of type <literal>B</literal> (the accumulator and result type), and return
a value of type <literal>B</literal>.</para>
</formalpara>
<screen>def B foldr&lt;A, B&gt;(accumulate)(List&lt;A&gt; l, B init);</screen>
</section>
</section>
<section xml:id="type-set">
<title>Sets</title>
<simpara>A set contains elements of the same type, without duplicates.  Sets are
constructed via the <literal>set</literal> constructor function, e.g., <literal>set[1, 2, 2, 3]</literal>
creates a set of three integers 1, 2, 3.  The expression <literal>set[]</literal> produces the
empty set.</simpara>
<simpara>To add an element to a set, use the function <literal>insertElement</literal>, to remove an
element, use <literal>remove</literal>.  To test for set membership, use the function
<literal>contains</literal>.</simpara>
<simpara>The <literal>takeMaybe</literal> function can be used to iterate through a set.  It is used as follows:</simpara>
<screen>def Unit printAll&lt;A&gt;(Set&lt;A&gt; set) =
  case takeMaybe(set) {
    Nothing =&gt; println("Finished");
    Just(e) =&gt; let (Unit dummy) = println("Element " + toString(e)) in printAll(remove(set, e));
  };</screen>
<section xml:id="-datatypes-and-constructors-6">
<title>Datatypes and Constructors</title>
<simpara>The datatype for sets with elements of type <literal>A</literal> is <literal>Set&lt;A&gt;</literal>.  The <literal>set</literal> constructor function is used to construct sets.</simpara>
</section>
<section xml:id="-functions-4">
<title>Functions</title>
<formalpara>
<title>contains</title>
<para>Returns <literal>True</literal> if set <literal>ss</literal> contains element <literal>e</literal>, <literal>False</literal> otherwise.</para>
</formalpara>
<screen>def Bool contains&lt;A&gt;(Set&lt;A&gt; ss, A e);</screen>
<formalpara>
<title>emptySet</title>
<para>Returns <literal>True</literal> if set <literal>xs</literal> is empty, <literal>False</literal>  otherwise.</para>
</formalpara>
<screen>def Bool emptySet&lt;A&gt;(Set&lt;A&gt; ss);</screen>
<formalpara>
<title>size</title>
<para>Returns the number of elements in set <literal>xs</literal>.</para>
</formalpara>
<screen>def Int size&lt;A&gt;(Set&lt;A&gt; xs);</screen>
<formalpara>
<title>elements</title>
<para>Returns a list with all elements in set <literal>xs</literal>.</para>
</formalpara>
<screen>def List&lt;A&gt; elements&lt;A&gt;(Set&lt;A&gt; xs);</screen>
<formalpara>
<title>union</title>
<para>Returns a set containing all elements of sets <literal>set1</literal> and <literal>set2</literal>.</para>
</formalpara>
<screen>def Set&lt;A&gt; union&lt;A&gt;(Set&lt;A&gt; set1, Set&lt;A&gt; set2);</screen>
<formalpara>
<title>intersection</title>
<para>Returns a set containing all elements that are present in both sets <literal>set1</literal> and
<literal>set2</literal>.</para>
</formalpara>
<screen>def Set&lt;A&gt; intersection&lt;A&gt;(Set&lt;A&gt; set1, Set&lt;A&gt; set2);</screen>
<formalpara>
<title>difference</title>
<para>Returns a set containing all elements of set <literal>set1</literal> not present in set <literal>set2</literal>.</para>
</formalpara>
<screen>def Set&lt;A&gt; difference&lt;A&gt;(Set&lt;A&gt; set1, Set&lt;A&gt; set2);</screen>
<formalpara>
<title>isSubset</title>
<para>Returns <literal>True</literal> if <literal>set</literal> contains all elements of <literal>maybe_subset</literal>, <literal>False</literal>
otherwise.</para>
</formalpara>
<screen>def Bool isSubset&lt;A&gt;(Set&lt;A&gt; maybe_subset, Set&lt;A&gt; set);</screen>
<formalpara>
<title>insertElement</title>
<para>Returns a set with all elements of set <literal>xs</literal> plus element <literal>e</literal>.  Returns a set
with the same elements as <literal>xs</literal> if <literal>xs</literal> already contains <literal>e</literal>.</para>
</formalpara>
<screen>def Set&lt;A&gt; insertElement&lt;A&gt;(Set&lt;A&gt; xs, A e);</screen>
<formalpara>
<title>remove</title>
<para>Returns a set with all elements of set <literal>xs</literal> except element <literal>e</literal>.  Returns a set
with the same elements as <literal>xs</literal> if <literal>xs</literal> did not contain <literal>e</literal>.</para>
</formalpara>
<screen>def Set&lt;A&gt; remove&lt;A&gt;(Set&lt;A&gt; xs, A e);</screen>
<formalpara>
<title>take</title>
<para>Returns one element from a non-empty set.  It is an error to call <literal>take</literal> on an
empty set; consider using <literal>takeMaybe</literal> in that case.</para>
</formalpara>
<screen>def A take&lt;A&gt;(Set&lt;A&gt; ss);</screen>
<formalpara>
<title>takeMaybe</title>
<para>Returns one element from a set, or <literal>Nothing</literal> for an empty set.</para>
</formalpara>
<screen>def Maybe&lt;A&gt; takeMaybe&lt;A&gt;(Set&lt;A&gt; ss);</screen>
</section>
</section>
<section xml:id="type-map">
<title>Maps</title>
<simpara>Maps are dictionaries storing a <emphasis>value</emphasis> for each <emphasis>key</emphasis>.</simpara>
<simpara>Maps are constructed using by passing a list of type <literal>Pair&lt;A, B&gt;</literal> to the <literal>map</literal>
constructor function.  The keys of the resulting map are of type <literal>A</literal> and
values are of type <literal>B</literal>.  The expression <literal>map[]</literal> produces an empty map.</simpara>
<simpara>The following example produces a map with two entries <literal>1 &#8594; "ABS"</literal> and <literal>3 &#8594;
"SACO"</literal>.</simpara>
<screen>Map&lt;Int, String&gt; m = map[Pair(1, "ABS"), Pair(3, "SACO")];</screen>
<note>
<simpara>In case of duplicate keys, it is unspecified which value the map will
contain for a given key.</simpara>
</note>
<simpara>The value associated with a key can be obtained using the <literal>lookup</literal> and
<literal>lookupDefault</literal> functions.</simpara>
<simpara>A map can be iterated over via the functions <literal>keys</literal>, <literal>values</literal> and <literal>entries</literal>,
which return the set of keys and the list of values and entries of the map,
respectively.</simpara>
<section xml:id="-datatypes-and-constructors-7">
<title>Datatypes and Constructors</title>
<simpara>The datatype for a map from type <literal>A</literal> to type <literal>B</literal> is is <literal>Map&lt;A, B&gt;</literal>.  The <literal>map</literal>
constructor function is used to construct maps.</simpara>
</section>
<section xml:id="-functions-5">
<title>Functions</title>
<formalpara>
<title>emptyMap</title>
<para>Returns <literal>True</literal> if the map is empty, <literal>False</literal> otherwise.</para>
</formalpara>
<screen>def Bool emptyMap&lt;A, B&gt;(Map&lt;A, B&gt; map);</screen>
<formalpara>
<title>removeKey</title>
<para>Returns a map with the first occurrence of <literal>key</literal> removed.</para>
</formalpara>
<screen>def Map&lt;A, B&gt; removeKey&lt;A, B&gt;(Map&lt;A, B&gt; map, A key);</screen>
<formalpara>
<title>values</title>
<para>Returns a list of all values within the map.</para>
</formalpara>
<screen>def List&lt;B&gt; values&lt;A, B&gt;(Map&lt;A, B&gt; map);</screen>
<formalpara>
<title>keys</title>
<para>Returns a set of all keys of the map.</para>
</formalpara>
<screen>def Set&lt;A&gt; keys&lt;A, B&gt;(Map&lt;A, B&gt; map);</screen>
<formalpara>
<title>entries</title>
<para>Returns a list of all entries (i.e., pairs of key and value) of the map.</para>
</formalpara>
<screen>def List&lt;Pair&lt;A, B&gt;&gt; entries&lt;A, B&gt;(Map&lt;A, B&gt; map);</screen>
<formalpara>
<title>lookup</title>
<para>If value <literal>v</literal> is associated with a given key <literal>k</literal>, return <literal>Just(v)</literal>.  Otherwise,
return <literal>Nothing</literal>.</para>
</formalpara>
<screen>def Maybe&lt;B&gt; lookup&lt;A, B&gt;(Map&lt;A, B&gt; ms, A k);</screen>
<formalpara>
<title>lookupDefault</title>
<para>Returns the value associated with key <literal>k</literal>.  If the map does not contain an
entry with key <literal>k</literal>, return the value <literal>d</literal>.</para>
</formalpara>
<screen>def B lookupDefault&lt;A, B&gt;(Map&lt;A, B&gt; ms, A k, B d);</screen>
<note>
<simpara>If you need to know whether the map contains an entry for key <literal>k</literal>, use the
function <literal>lookup</literal> instead.</simpara>
</note>
<formalpara>
<title>lookupUnsafe</title>
<para>Returns the value associated with key <literal>k</literal>.  It is an error if the map does not
contain an entry with key <literal>k</literal>.</para>
</formalpara>
<screen>def B lookupUnsafe&lt;A, B&gt;(Map&lt;A, B&gt; ms, A k);</screen>
<formalpara>
<title>insert</title>
<para>Returns a map with all entries of <literal>map</literal> plus an entry <literal>p</literal>, which is given as a
pair (<literal>Pair(key, value)</literal>) and maps <literal>key</literal> to <literal>value</literal>.  If <literal>map</literal> already
contains an entry with the same key <literal>key</literal>, it is not removed from the map but
<literal>lookup</literal> will return the new value <literal>value</literal>.  (The function <literal>removeKey</literal> removes
the first entry for a given key and thus “undoes” the effect of calling
<literal>insert</literal>.)</para>
</formalpara>
<screen>def Map&lt;A, B&gt; insert&lt;A, B&gt;(Map&lt;A, B&gt; map, Pair&lt;A, B&gt; p);</screen>
<formalpara>
<title>put</title>
<para>Returns a map with all entries of <literal>ms</literal> plus an entry mapping <literal>k</literal> to <literal>v</literal>, minus
the first entry already mapping <literal>k</literal> to a value.</para>
</formalpara>
<screen>def Map&lt;A, B&gt; put&lt;A, B&gt;(Map&lt;A, B&gt; ms, A k, B v);</screen>
</section>
</section>
<section xml:id="type-pair">
<title>Pairs</title>
<section xml:id="-datatypes-and-constructors-8">
<title>Datatypes and Constructors</title>
<simpara>The <literal>Pair&lt;A, B&gt;</literal> datatype holds a pair of values of types <literal>A</literal> and <literal>B</literal>,
respectively.  The constructor is called <literal>Pair</literal> as well.</simpara>
<screen>Pair&lt;Int, String&gt; pair = Pair(15, "Hello World");</screen>
</section>
<section xml:id="-functions-6">
<title>Functions</title>
<formalpara>
<title>fst</title>
<para>The function <literal>fst</literal> returns the first value in a pair.</para>
</formalpara>
<formalpara>
<title>snd</title>
<para>The function <literal>snd</literal> returns the second value in a pair.</para>
</formalpara>
</section>
</section>
<section xml:id="type-triple">
<title>Triples</title>
<section xml:id="-datatypes-and-constructors-9">
<title>Datatypes and Constructors</title>
<simpara>The <literal>Triple&lt;A, B, C&gt;</literal> datatype holds a triple of values of types <literal>A</literal>, <literal>B</literal> and
<literal>C</literal>, respectively.  The constructor is called <literal>Triple</literal> as well.</simpara>
<screen>Triple&lt;Int, String, Bool&gt; triple = Pair(15, "Hello World", False);</screen>
</section>
<section xml:id="-functions-7">
<title>Functions</title>
<formalpara>
<title>fstT</title>
<para>The function <literal>fstT</literal> returns the first value in a triple.</para>
</formalpara>
<formalpara>
<title>sndT</title>
<para>The function <literal>sndT</literal> returns the second value in a triple.</para>
</formalpara>
<formalpara>
<title>trdT</title>
<para>The function <literal>trdT</literal> returns the third value in a triple.</para>
</formalpara>
</section>
</section>
<section xml:id="type-optionals">
<title>Optionals</title>
<section xml:id="-datatypes-and-constructors-10">
<title>Datatypes and Constructors</title>
<simpara>The datatype <literal>Maybe&lt;A&gt;</literal> wraps a concrete value of type A.  The value <literal>Nothing</literal>
denotes the absence of such a value.</simpara>
<screen>Maybe&lt;Int&gt; answer = Just(42);
Maybe&lt;String&gt; question = Nothing;</screen>
</section>
<section xml:id="-functions-8">
<title>Functions</title>
<formalpara>
<title>isJust</title>
<para>The function <literal>isJust</literal> returns <literal>False</literal> if the <literal>Maybe</literal> value is <literal>Nothing</literal>,
<literal>True</literal> otherwise.</para>
</formalpara>
<screen>def Bool isJust&lt;A&gt;(Maybe&lt;A&gt; a);</screen>
<formalpara>
<title>fromJust</title>
<para>The function <literal>fromJust</literal> returns the wrapped value of a <literal>Maybe</literal>.  It is an error to call <literal>fromJust</literal> on <literal>Nothing</literal>.</para>
</formalpara>
<screen>def A fromJust&lt;A&gt;(Maybe&lt;A&gt; m);</screen>
</section>
</section>
</chapter>
<chapter xml:id="-the-model-api">
<title>The Model API</title>
<simpara>The Erlang backend supports querying a running model.  When creating objects,
an annotation <literal>HTTPName</literal> makes them available via HTTP requests from outside
the model under the name given by the annotation.  Methods that are annotated
<literal>HTTPCallable</literal> can be invoked from the outside on such objects.  Additionally,
datatypes can be annotated to influence how they are converted to JSON when
they are returned from such methods.</simpara>
<simpara>The model API is supported by the Erlang backend.</simpara>
<note>
<simpara>All queries in this section can be prepended with a <literal>/v2/</literal> prefix, i.e.,
<literal><link xlink:href="http://localhost:8080/v2/call">http://localhost:8080/v2/call</link></literal> instead of <literal><link xlink:href="http://localhost:8080/call">http://localhost:8080/call</link></literal>.  In
case incompatible changes have to be introduced to the Model API in the
future, the semantics of invocations of queries with prefix <literal>/v2/</literal> will be
preserved.</simpara>
</note>
<section xml:id="-starting-the-model-api">
<title>Starting the Model API</title>
<simpara>When an ABS model compiled with the Erlang backend is started with the <literal>-p</literal>
parameter naming a port number, the model will listen on the specified port
for requests.  In the following example, we compile a model <literal>my-model.abs</literal> and
start the model API on port 8080:</simpara>
<screen>$ absc -erlang my-model.abs
$ gen/erl/run -p 8080</screen>
</section>
<section xml:id="-shutting-down-the-model-api">
<title>Shutting down the Model API</title>
<simpara>When running a model with the model API activated, it will not return to the
command line after the simulation has finished.  Instead, the model will keep
listening for requests and method calls.</simpara>
<simpara>A running model can be terminated manually from the console (for example, via
pressing <literal>Ctrl-C</literal>), or by requesting the URL <literal>/quit</literal>.  The following command
will terminate a model running on port 8080:</simpara>
<screen>$ curl localhost:8080/quit
curl: (52) Empty reply from server</screen>
</section>
<section xml:id="-exposing-objects">
<title>Exposing objects</title>
<simpara>Objects are exposed via a <literal>HTTPName</literal> annotation.  In the following example,
two objects of class <literal>C</literal> are exposed with the names <literal>C1</literal> and <literal>C2</literal>
respectively.  The <literal>HTTPName</literal> annotation can be used on assignment statements,
variable declarations and <literal>new</literal> expression statements.</simpara>
<screen>[HTTPName: "C1"] new C();
[HTTPName: "C2"] I x = new C();</screen>
</section>
<section xml:id="-exposing-methods">
<title>Exposing methods</title>
<simpara>In an interface declaration, a <literal>HTTPCallable</literal> annotation exposes the annotated
method such that it is callable from outside, given an exposed object that implements that interface.</simpara>
<screen>interface I {
  [HTTPCallable] String method(String param1, Int param2);
}</screen>
<simpara>It is a compile-time error if the method takes parameters whose types are not
supported.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="34*"/>
<thead>
<row>
<entry align="left" valign="top">ABS type</entry>
<entry align="left" valign="top">URLencoded format</entry>
<entry align="left" valign="top">JSON format</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
<entry align="left" valign="top"><simpara>literal upper- or lowercase <literal>true</literal> / <literal>false</literal>: <literal>?p=True</literal>, <literal>?p=true</literal>, <literal>?p=False</literal>, <literal>?p=false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Int</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a string of digits, e.g., <literal>?p=42</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON integer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>URLEncoded text, e.g., <literal>?p=Hello%20World!</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>List&lt;A&gt;</literal> (where <literal>A</literal> can be decoded)</simpara></entry>
<entry align="left" valign="top"><simpara>not supported</simpara></entry>
<entry align="left" valign="top"><simpara>JSON list with elements of type <literal>A</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>All others</simpara></entry>
<entry align="left" valign="top"><simpara>not supported</simpara></entry>
<entry align="left" valign="top"><simpara>not supported</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The method can have any return type.  Method call results will be returned as
a string via the ABS <literal>toString()</literal> function, except for the types enumerated in
the following table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="67*"/>
<thead>
<row>
<entry align="left" valign="top">ABS type</entry>
<entry align="left" valign="top">JSON format</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Bool</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON boolean value</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON string value</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Int</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON integer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Rat</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON float, via integer division.  The behavior is unspecified if
  the <literal>Rat</literal> value is outside of floating point range.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>List&lt;A&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON list, with elements converted one-by-one per this table.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Set&lt;A&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON list; guaranteed to contain no duplicate elements, with
  elements converted one-by-one per this table.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Map&lt;A, B&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>JSON object, with keys generated from their ABS counterpart
  via <literal>toString()</literal>, values converted per this table.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Datatype, with at least one named or annotated constructor argument</simpara></entry>
<entry align="left" valign="top"><simpara>JSON
  object (see below)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Others</simpara></entry>
<entry align="left" valign="top"><simpara>Converted via ABS <literal>toString()</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>User-defined datatypes are encoded depending on the presence of accessor
functions and <literal>HTTPName</literal> annotations.  If the datatype definition contains
neither, values will be encoded as strings via <literal>toString()</literal>.  If at least one
accessor function or <literal>HTTPName</literal> annotation is present, values will be encoded
as objects, with the <literal>HTTPName</literal> annotation value (or accessor function name,
if no annotation is present) as key.  Unnamed constructor argument values will
not be contained in the JSON object.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Example of encoding of user-defined data types</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">ABS definition</entry>
<entry align="left" valign="top">Sample JSON encoding</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>data D1 = D1(String, Int);</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'D1("x", 1)'</literal>, as per <literal>toString()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>data D2 = D2(String key, Int);</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>{ 'key': 'x' }</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>data D3 = D3([HTTPName: "effective key"] String key, Int);</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>{ 'effective key': 'x' }</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="-querying-object-state">
<title>Querying object state</title>
<simpara>The following query returns the names of all exposed objects.</simpara>
<screen>GET http://localhost:8080/o</screen>
<simpara>Inspecting an object state directly can be useful for debugging.  The
following query returns a JSON map of the state of the object exposed as <literal>C1</literal>,
with object fields as keys.</simpara>
<screen>GET http://localhost:8080/o/C1</screen>
<simpara>The following query returns a JSON map containing the value of <literal>C1&#8217;s `field</literal>,
with <literal>"field"</literal> as key.</simpara>
<screen>GET http://localhost:8080/o/C1/field</screen>
<simpara>When querying for an unknown object or an unknown field, the HTTP request will
produce a 404 response code.</simpara>
<note>
<simpara>All queries in this section can be prepended with a <literal>/v2/</literal> prefix, i.e.,
<literal><link xlink:href="http://localhost:8080/v2/o">http://localhost:8080/v2/o</link></literal>.  In case incompatible changes are introduced
to the Model API in the future, for example by introducing new return value
encodings, reasonable effort will be made to keep the semantics of invocations
of queries with prefix <literal>/v2/</literal> unchanged.</simpara>
</note>
</section>
<section xml:id="-querying-exported-methods-of-an-object">
<title>Querying exported methods of an object</title>
<simpara>The following query returns, for an object exposed as <literal>C1</literal>, a JSON array of
objects with metadata about callable functions.</simpara>
<screen>GET http://localhost:8080/call/C1</screen>
<simpara>Each entry in the resulting list will be a JSON object with the following
keys:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>name</literal>: the name of the exposed method</simpara>
</listitem>
<listitem>
<simpara><literal>parameters</literal>: an array with one object per parameter, each with the
following entries:</simpara>
</listitem>
<listitem>
<simpara><literal>name</literal>: name of the parameter</simpara>
</listitem>
<listitem>
<simpara><literal>type</literal>: type of the parameter</simpara>
</listitem>
<listitem>
<simpara><literal>return</literal>: return type of the method</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="-invoking-methods">
<title>Invoking methods</title>
<simpara>Exposed methods are called by querying a URL of the form</simpara>
<screen>http://.../call/&lt;objectname&gt;/&lt;methodname&gt;</screen>
<simpara>Parameters are passed to methods either as query parameters in the URL or in a
JSON map passed in as the body of a POST request.  For duplicate arguments,
parameter values in the URL override values given in the JSON body.</simpara>
<simpara>The following query produces the return value of the method call
<literal>method("value", 50)</literal> by invoking it on the object exposed as <literal>C1</literal>.</simpara>
<screen>GET http://localhost:8080/call/C1/method?param1=value&amp;param2=50</screen>
<simpara>This query can be invoked from the shell in two ways, using the <literal>curl</literal>
command, either using query parameters or a JSON body:</simpara>
<screen>$ curl http://localhost:8080/call/C1/method?param1=value\&amp;param2=50
$ curl -d "{ 'param1': 'value', 'param2': 50 }" http://localhost:8080/call/C1/method</screen>
<simpara>Care must be taken to disable timeouts on the HTTP client when querying for
long-running methods in this way.</simpara>
<simpara>When querying for unknown objects or methods, the HTTP request will produce a
404 response code.</simpara>
<simpara>When querying with invalid method parameters, the HTTP request will produce a
400 response code.</simpara>
<simpara>When the invoked method throws an exception, the HTTP request will produce a
500 response code.</simpara>
</section>
</chapter>
<chapter xml:id="sec:timed-abs">
<title>Timed ABS</title>
<simpara>Timed ABS is an extension to the core ABS language that introduces a notion of
<emphasis>abstract time</emphasis>.  Timed ABS can be used to model not only the functional
behavior but also the timing-related behavior of real systems running on real
hardware.  In contrast to real systems, time in an ABS model does not advance
by itself.  The time model of Timed ABS takes inspiration from formalisms such
as <link xlink:href="http://uppaal.org">Timed Automata</link> and
<link xlink:href="http://heim.ifi.uio.no/~peterol/RealTimeMaude/">Real-Time Maude</link>.</simpara>
<note>
<simpara>All untimed ABS models are valid in Timed ABS.  An ABS model that
contains no time-influencing statements will run without influencing the clock
and will finish at time zero.</simpara>
</note>
<simpara>The ABS notion of time is <emphasis>dense time</emphasis> with <emphasis>run-to-completion semantics</emphasis>.
Timed ABS adds a clock to the language semantics that advances in response to
certain language constructs.  Time is expressed as a rational number, so the
clock can advance in infinitesimally small steps.</simpara>
<simpara>It is possible to assign <emphasis>deadlines</emphasis> to method calls.  Deadlines are expressed
in terms of a duration value relative to the current time and decrease as the
clock advances.  The current deadline of a method is available via the
function <literal>deadline</literal> and decreases down to zero.</simpara>
<simpara>Time only advances when all processes are blocked or suspended and no process
is ready to run.  This means that for time to advance, all processes are in
one of the following states:</simpara>
<itemizedlist>
<listitem>
<simpara>the process is awaiting for a guard that is not enabled (see <xref linkend="await-stmt"/>)</simpara>
</listitem>
<listitem>
<simpara>the process is blocked on a future that is not available (see
<xref linkend="get-expression"/>)</simpara>
</listitem>
<listitem>
<simpara>the process is suspended waiting for time to advance</simpara>
</listitem>
<listitem>
<simpara>the process is waiting for some resources</simpara>
</listitem>
</itemizedlist>
<simpara>In practice this means that all processes run as long as there is “work to be
done.”</simpara>
<section xml:id="-datatypes-and-constructors-11">
<title>Datatypes and Constructors</title>
<simpara>Time is expressed as a datatype <literal>Time</literal>, durations are expressed using the
datatype <literal>Duration</literal>, which can be infinite.  These datatypes are defined in
the standard library as follows:</simpara>
<screen>data Time = Time(Rat timeValue);
data Duration = Duration(Rat durationValue) | InfDuration;</screen>
</section>
<section xml:id="-functions-9">
<title>Functions</title>
<formalpara>
<title>now</title>
<para>The function <literal>now</literal> always returns the current time.</para>
</formalpara>
<screen>def Time now()</screen>
<simpara>Note that since ABS uses simulated time, two calls to <literal>now</literal> can return the same
value.  Specifically, the result of <literal>now()</literal> changes only by executing
<literal>duration</literal> or <literal>await duration</literal> statements, or by waiting for resources to
become available.</simpara>
<screen>  Time t1 = now();
  Int i = pow(2, 50);
  Time t2 = now();
  assert (t1 == t2); <co xml:id="CO21-1"/></screen>
<calloutlist>
<callout arearefs="CO21-1">
<para>This assertion will not fail, since no time has passed in the model.  Time
advance in ABS is explicit and can only occur in suspension points.</para>
</callout>
</calloutlist>
<formalpara>
<title>deadline</title>
<para>The function <literal>deadline</literal> returns the deadline of the current process.</para>
</formalpara>
<screen>def Duration deadline()</screen>
<simpara>The initial value of a deadline is set via a <literal>Deadline</literal> annotation at the
caller site.</simpara>
<screen>Unit m() {
  [Deadline: Duration(10)] this!n(); <co xml:id="CO22-1"/>
}

Unit n() {
  Duration d1 = deadline(); <co xml:id="CO22-2"/>
  await duration(2, 2);
  Duration d2 = deadline(); <co xml:id="CO22-3"/>
}</screen>
<calloutlist>
<callout arearefs="CO22-1">
<para>The <literal>Deadline</literal> annotation assigns a deadline to the process started by the asynchronous method call</para>
</callout>
<callout arearefs="CO22-2">
<para>The process can query its current deadline; if no deadline is given, <literal>deadline</literal> returns <literal>InfDuration</literal></para>
</callout>
<callout arearefs="CO22-3">
<para><literal>d2</literal> will be two time units less than <literal>d1</literal></para>
</callout>
</calloutlist>
</section>
<section xml:id="-statements-2">
<title>Statements</title>
<simpara>The <literal>duration(min, max)</literal> statement blocks the cog of the executing process
until at least <literal>min</literal> and at most <literal>max</literal> time units have passed.  The <literal>await
duration(min, max)</literal> statement (see <xref linkend="await-stmt"/>) suspends the current
process until at least <literal>min</literal> and at most <literal>max</literal> time units have passed.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>DurationStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>duration</literal> <literal>(</literal> <emphasis>PureExp</emphasis> <literal>,</literal> <emphasis>PureExp</emphasis> <literal>)</literal> <literal>;</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>AwaitStmt</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>await</literal> <emphasis>Guard</emphasis> <literal>;</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>Guard</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203; | <emphasis>DurationGuard</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>DurationGuard</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>duration</literal> <literal>(</literal> <emphasis>PureExp</emphasis> <literal>,</literal> <emphasis>PureExp</emphasis> <literal>)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The difference between <literal>duration</literal> and <literal>await duration</literal> is that in the latter
case other processes in the same cog can execute while the awaiting process is
suspended.  In the case of the blocking <literal>duration</literal> statement, no other process
in the same cog can execute.  Note that processes in other cogs are not
influenced by <literal>duration</literal> or <literal>await duration</literal>, except when they attempt to
synchronize with that process.</simpara>
<note>
<simpara>A subtle difference between <literal>duration</literal> and <literal>await duration</literal> is that in
the latter case, the suspended process becomes eligible for scheduling after
the specified time, but there is no guarantee that it will actually be
scheduled at that point.  This means that more time might pass than expressed in the <literal>await duration</literal> guard!</simpara>
</note>
<formalpara>
<title>Examples</title>
<para>
<screen>  Time t = now();
  await duration(1/2, 5); <co xml:id="CO23-1"/>
  Time t2 = now(); <co xml:id="CO23-2"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO23-1">
<para>Here the <emphasis role="strong">process</emphasis> suspends for 1/2-5 time units</para>
</callout>
<callout arearefs="CO23-2">
<para><literal>t2</literal> will be at least 1/2 time units larger than <literal>t</literal></para>
</callout>
</calloutlist>
<screen>  Time t = now();
  duration(1/2, 5); <co xml:id="CO24-1"/>
  Time t2 = now(); <co xml:id="CO24-2"/></screen>
<calloutlist>
<callout arearefs="CO24-1">
<para>Here the <emphasis role="strong">cog</emphasis> blocks for 1/2-5 time units</para>
</callout>
<callout arearefs="CO24-2">
<para><literal>t2</literal> will be between 1/2 and 5 time units larger than <literal>t</literal></para>
</callout>
</calloutlist>
</section>
<section xml:id="-semantics-of-time-advancement">
<title>Semantics of Time Advancement</title>
<simpara>The simulated clock advances such that it makes the least amount of “jumps”
without missing any point of interest.  This means that when a process waits
or blocks for an interval <emphasis>(min, max)</emphasis>, the clock will not advance more than
<emphasis>max</emphasis>, since otherwise it would miss unblocking the process.  On the other
hand, the clock will advance by the highest amount allowed by the model.  This
means that if only one process waits for <emphasis>(min, max)</emphasis>, the clock will advance
by <emphasis>max</emphasis>.</simpara>
<figure xml:id="fig-time-advance">
<title>Big-step time advance</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ABS-time-advance.png" contentwidth="510" contentdepth="150"/>
</imageobject>
<textobject><phrase>Big-step time advance</phrase></textobject>
</mediaobject>
</figure>
<simpara>Figure <xref linkend="fig-time-advance"/> shows a timeline with two process, <literal>P1</literal> and <literal>P2</literal>.
They are waiting for time to advance between <literal>(4, 6)</literal> and <literal>(3, 5)</literal> units,
respectively.  Assuming that no other process is ready to run, the clock will
advance the maximum amount that still hits the earliest interval, in this
case 5.  Since the clock is now within both intervals, both processes are
unblocked and ready to run.</simpara>
</section>
</chapter>
<chapter xml:id="sec:schedulers">
<title>User-Defined Schedulers</title>
<simpara>User-defined schedulers are an experimental feature of Timed ABS.  They are
available on the Maude and Erlang backends.  This section describes the
current state of the implementation on the Erlang backend.</simpara>
<simpara>All identifiers introduced in this section reside in the <literal>ABS.Scheduler</literal>
module, which is not imported by default.</simpara>
<section xml:id="-defining-schedulers">
<title>Defining Schedulers</title>
<simpara>A scheduler is a function that takes a list of processes and chooses one of
them.  Schedulers are ordinary ABS functions.</simpara>
<simpara>The following two example schedulers illustrate the concept.  The first,
deterministic scheduler takes the first process off the list; the second
scheduler chooses a non-deterministic one.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>def Process defaultscheduler(List&lt;Process&gt; queue) = head(queue);

def Process randomscheduler(List&lt;Process&gt; queue) = nth(queue, random(length(queue)));</screen>
</para>
</formalpara>
<simpara>It is possible to formulate an Earliest Deadline First (EDF) scheduler in ABS:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>def Process find_shortest_deadline(Process candidate, List&lt;Process&gt; l) =
  if l == Nil then candidate
  else if durationLessThan(proc_deadline(head(l)), proc_deadline(candidate))
    then find_shortest_deadline(head(l), tail(l))
    else find_shortest_deadline(candidate, tail(l));

def Process earliest_deadline_scheduler(List&lt;Process&gt; queue) =
find_shortest_deadline(head(queue), tail(queue));</screen>
</para>
</formalpara>
<simpara>All schedulers must have a result type <literal>Process</literal> and must take an argument of
type <literal>List&lt;Process&gt;</literal> as their first argument.</simpara>
<note>
<simpara>Schedulers can have more than one argument; arguments after the first
one will be filled with the value of object fields at scheduling time.  This
feature is available in the Maude backend only but will be implemented in the
Erlang backend as well.</simpara>
</note>
</section>
<section xml:id="-processes-and-process-attributes">
<title>Processes and Process Attributes</title>
<simpara>A <emphasis>process</emphasis> is an ABS abstract datatype; i.e., there is no constructor
available to create a <literal>Process</literal> value inside ABS.  Processes are created by
the runtime and handed to schedulers.</simpara>
<simpara>Processes have <emphasis>attributes</emphasis> which can be used by schedulers to choose the next
process to run.  For example, a scheduler could always prefer processes that
run a certain method.  The following attributes are available:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>method</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the method executed by the process</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>arrival</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Time</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Time when method call was issued</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>proc_deadline</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Duration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The (current) deadline value of the process (<literal>InfDuration</literal> if none)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>The attributes <literal>cost</literal>, <literal>start</literal>, <literal>crit</literal> are available in
the Maude backend only but will be implemented in the Erlang backend as well.
The attributes <literal>value</literal>, <literal>finish</literal> are under consideration since their
usefulness is questionable.</simpara>
</note>
</section>
<section xml:id="-using-schedulers">
<title>Using Schedulers</title>
<simpara>Schedulers apply to <emphasis>cogs</emphasis> since cogs are responsible for scheduling one of
their processes when idle.  Since cogs are created via <literal>new</literal> expressions, a
scheduler can be given at that point via an annotation.  Classes can have a
<emphasis>default scheduler</emphasis> that is given as an annotation to the class definition;
any cog created when instantiating this class will have that scheduler by
default (unless overridden by an annotation at the <literal>new</literal> expression).</simpara>
<simpara>The following example shows how to define a class that uses the
<literal>randomscheduler</literal> by default.  The first argument (the list of processes) must
have the name <literal>queue</literal>.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>[Scheduler: defaultscheduler(queue)] class C implements I {
  ...
}</screen>
</para>
</formalpara>
<simpara>The following example shows how to create a cog with a different scheduler.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>   [Scheduler: randomscheduler(queue)] I instance = new C();</screen>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="sec:deployment">
<title>Deployment and Resource Modeling</title>
<simpara>This chapter describes how to model non-functional properties of systems: code
deployment on varying numbers and kinds of machines, and the effects of code
locality and different resource types such as CPU speeds, interconnection
bandwidth, etc. on the performance of a system.</simpara>
<simpara>To simulate the effects of deployment decisions on the cost and performance of
running a distributed system, the following aspects need to be added to a
model:</simpara>
<itemizedlist>
<listitem>
<simpara>A notion of <emphasis>location</emphasis> to describe where different parts of the system will
run</simpara>
</listitem>
<listitem>
<simpara>A notion of <emphasis>cost</emphasis> of executing code on such locations; and finally</simpara>
</listitem>
<listitem>
<simpara>A notion of <emphasis>time</emphasis> that allows us to observe the effects of varying the
location and cost.</simpara>
</listitem>
</itemizedlist>
<simpara>In ABS, the following language elements implement these aspects:</simpara>
<variablelist>
<varlistentry>
<term>Deployment Components </term>
<listitem>
<simpara>ABS cogs can be created on a deployment component
(see <xref linkend="sec:deployment-components"/>).  Deployment components have a limited
number of resources available.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resource Annotations </term>
<listitem>
<simpara>ABS statements can be annotated with resource costs
(see <xref linkend="sec:resources"/>).  Executing such annotated statements incurs resource costs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timed ABS </term>
<listitem>
<simpara>The time model of Section <xref linkend="sec:timed-abs"/> naturally extends to
observations on resource usage.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>These elements work together as in Figure <xref linkend="fig-resource-consumption"/>:</simpara>
<figure xml:id="fig-resource-consumption">
<title>Resource Consumption</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ABS-resources.png" contentwidth="676" contentdepth="431"/>
</imageobject>
<textobject><phrase>Resource Consumption</phrase></textobject>
</mediaobject>
</figure>
<simpara>The figure shows a process with a <literal>skip</literal> statement with an associated cost of
5, followed by a <literal>println</literal> statement with a cost of 10.  The deployment
component <literal>DC</literal> has 10 resources available in each time interval.</simpara>
<simpara>At time <literal>t</literal>, the <literal>skip</literal> statement consumes the five needed resources and is
successfully executed.  The <literal>println</literal> statement consumes the remaining five
resources but is not executed yet.</simpara>
<simpara>At time <literal>t+1</literal>, the deployment component’s resources are refilled.  The five
remaining resources of the <literal>println</literal> statement are consumed and the statement
is executed.  The five remaining resources of <literal>DC</literal> are not used.</simpara>
<simpara>At time <literal>t+2</literal>, the deployment component’s resources are again refilled to 10.</simpara>
<simpara>The rest of this chapter explains these language elements concerning resource
modeling in detail.  All identifiers introduced in this section reside in the
<literal>ABS.DC</literal> module.</simpara>
<section xml:id="sec:cloudprovider">
<title>The CloudProvider API</title>
<simpara>Deployment components are usually managed by a <emphasis>Cloud Provider</emphasis> instance.  The
Cloud Provider implements the life cycle shown in Figure
<xref linkend="fig-instance-lifecycle"/>.  A deployment component is <emphasis>managed</emphasis> by a cloud
provider if it was created via one of the <literal>launchInstance</literal> methods.</simpara>
<figure xml:id="fig-instance-lifecycle">
<title>Deployment Component lifecycle</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Cloud-API.png" contentwidth="475" contentdepth="727"/>
</imageobject>
<textobject><phrase>Deployment Component lifecycle</phrase></textobject>
</mediaobject>
</figure>
<simpara>The operations supported by deployment components during their lifecycle are
summarized in Table <xref linkend="table-dc-lifecycle"/>.</simpara>
<informaltable xml:id="table-dc-lifecycle" frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">State</entry>
<entry align="left" valign="top">Starting</entry>
<entry align="left" valign="top">Running</entry>
<entry align="left" valign="top">Terminating</entry>
<entry align="left" valign="top">Terminated</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Create objects</simpara></entry>
<entry align="left" valign="top"><simpara>delayed</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Invoke methods</simpara></entry>
<entry align="left" valign="top"><simpara>delayed</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Process keep running</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>yes/no</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="-using-the-cloudprovider">
<title>Using the CloudProvider</title>
<simpara>To use deployment components via a cloud provider, follow these steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a <literal>CloudProvider</literal> instance</simpara>
</listitem>
<listitem>
<simpara>Set the instance descriptions via the <literal>setInstanceDescriptions</literal> method</simpara>
</listitem>
<listitem>
<simpara>Create deployment components using the <literal>launchInstanceNamed</literal> method</simpara>
</listitem>
<listitem>
<simpara>(optional) Manage access via <literal>releaseInstance</literal> / <literal>acquireInstance</literal></simpara>
</listitem>
<listitem>
<simpara>(optional) Release deployment components via <literal>shutdownInstance</literal></simpara>
</listitem>
</orderedlist>
<screen>module ProviderDemo;
import * from ABS.DC;

{
    CloudProvider p = new CloudProvider("Amazon");
    await p!setInstanceDescriptions(
        map[Pair("T2_MICRO", map[Pair(Memory,1), Pair(Speed,1)]),
            Pair("T2_SMALL", map[Pair(Memory,2), Pair(Speed,1)]),
            Pair("T2_MEDIUM", map[Pair(Memory,4), Pair(Speed,2)]),
            Pair("M4_LARGE", map[Pair(Memory,8), Pair(Speed,2)])]);
    DeploymentComponent dc = await p!launchInstanceNamed("T2_SMALL");
    // ... use the deployment component ...
}</screen>
</section>
<section xml:id="-datatypes-and-constructors-12">
<title>Datatypes and Constructors</title>
<simpara>The type for cloud provider instances is <literal>ABS.DC.CloudProvider</literal>.</simpara>
<simpara>Cloud provider instances are created with a <literal>new CloudProvider(String name)</literal>
expression.  It is not mandatory but recommended that each cloud provider
instance has a unique name.</simpara>
<simpara>It is recommended to call <literal>setInstanceDescriptions</literal> once after creating a
cloud provider to set the list of named instance types that this cloud
provider offers.</simpara>
</section>
<section xml:id="-methods">
<title>Methods</title>
<formalpara>
<title>setInstanceDescriptions</title>
<para>This method sets the named instance configurations that the cloud provider
instance should support.  These names are used in the methods
<literal>launchInstanceNamed</literal> and <literal>prelaunchInstanceNamed</literal>.</para>
</formalpara>
<screen>[Atomic] Unit setInstanceDescriptions(Map&lt;String, Map&lt;Resourcetype, Rat&gt;&gt; instanceDescriptions);</screen>
<formalpara>
<title>getInstanceDescriptions</title>
<para>This method returns the map of named instance configurations.</para>
</formalpara>
<screen>[Atomic] Map&lt;String, Map&lt;Resourcetype, Rat&gt;&gt; getInstanceDescriptions();</screen>
<formalpara>
<title>launchInstanceNamed</title>
<para>This method creates and returns a new deployment component with a resource
configuration corresponding to <literal>instancename</literal>, as set by the
<literal>setInstanceDescriptions</literal> method.  If no description for <literal>instancename</literal>
exists, <literal>launchInstanceNamed</literal> returns <literal>null</literal>.</para>
</formalpara>
<screen>DeploymentComponent launchInstanceNamed(String instancename);</screen>
<simpara>The name of the new deployment component will be <literal>"&lt;Cloud provider
name&gt;-&lt;instancename&gt;-&lt;Counter&gt;"</literal>, i.e., a concatenation of the name of the
cloud provider itself, the instance name, and a unique integer as suffix.</simpara>
<simpara>If the instance description specifies a startup duration,
<literal>launchInstanceNamed</literal> will only return after that amount of simulated time has
elapsed.</simpara>
<simpara>The returned deployment component will be acquired (as per <literal>acquireInstance</literal>)
and can be used immediately.</simpara>
<formalpara>
<title>prelaunchInstanceNamed</title>
<para>This method creates and returns a new deployment component with a resource
configuration corresponding to <literal>instancename</literal>, as set by the
<literal>setInstanceDescriptions</literal> method.  If no description for <literal>instancename</literal>
exists, <literal>prelaunchInstanceNamed</literal> returns <literal>null</literal>.</para>
</formalpara>
<screen>DeploymentComponent prelaunchInstanceNamed(String instancename);</screen>
<simpara>As with <literal>launchInstance</literal>, the name of the new deployment component will be
<literal>"&lt;Cloud provider name&gt;-&lt;instancename&gt;-&lt;Counter&gt;"</literal>, i.e., a concatenation of
the name of the cloud provider itself, the instance name, and a unique integer
as suffix.</simpara>
<simpara>The method <literal>prelaunchInstanceNamed</literal> returns immediately, but the method
<literal>acquireInstance</literal>, when called on the returned deployment component, will not
return before its startup duration (if specified) has elapsed.</simpara>
<simpara>The returned deployment component needs to be acquired (as per
<literal>acquireInstance</literal>) before it can be used.</simpara>
<formalpara>
<title>launchInstance</title>
<para>The <literal>launchInstance</literal> method creates and returns a new deployment component
with the specified resource configuration.  It can be used when, for whatever
reason, the resource configuration should not be registered with the cloud
provider, but the deployment component should still be managed by it.</para>
</formalpara>
<screen>DeploymentComponent launchInstance(Map&lt;Resourcetype, Rat&gt; description);</screen>
<simpara>The name of the new deployment component will be <literal>"&lt;Cloud provider
name&gt;-&lt;Counter&gt;"</literal>, i.e., a concatenation of the name of the
cloud provider itself and a unique integer as suffix.</simpara>
<simpara>If the resource configuration specifies a startup duration,
<literal>launchInstanceNamed</literal> will only return after that amount of simulated time has
elapsed.</simpara>
<simpara>The returned deployment component will be acquired (as per <literal>acquireInstance</literal>)
and can be used immediately.</simpara>
<formalpara>
<title>prelaunchInstance</title>
<para>This method creates and returns a new deployment component with the specified
resource configuration.  As with <literal>launchInstance</literal>, this method can be used
when, for whatever reason, the resource configuration should not be registered
with the cloud provider, but the deployment component should still be managed
by it.</para>
</formalpara>
<screen>DeploymentComponent prelaunchInstance(Map&lt;Resourcetype, Rat&gt; d)</screen>
<simpara>The name of the new deployment component will be <literal>"&lt;Cloud provider
name&gt;-&lt;Counter&gt;"</literal>, i.e., a concatenation of the name of the cloud provider
itself and a unique integer as suffix.</simpara>
<simpara>The method <literal>prelaunchInstance</literal> returns immediately, but the method
<literal>acquireInstance</literal>, when called on the returned deployment component, will not
return before its startup duration (if specified) has elapsed.</simpara>
<simpara>The returned deployment component needs to be acquired (as per
<literal>acquireInstance</literal>) before it can be used.</simpara>
<formalpara>
<title>acquireInstance</title>
<para>This method, together with <literal>releaseInstance</literal>, implements exclusive access to a
deployment component.  After <literal>acquireInstance</literal> returns true, all further
invocations will return false until <literal>releaseInstance</literal> is called for the
deployment component.</para>
</formalpara>
<screen>Bool acquireInstance(DeploymentComponent instance);</screen>
<simpara>If the deployment component passed as argument was not created by the cloud
provider, the method returns false.</simpara>
<note>
<simpara>The methods <literal>acquireInstance</literal> and <literal>releaseInstance</literal> are used to
implement exclusive access in a <emphasis>cooperative</emphasis> manner.  Attempting to create a
cog on a deployment component without having acquired it beforehand will not
lead to a runtime error; ensuring exclusive access to deployment components is
the responsibility of the modeler.</simpara>
</note>
<formalpara>
<title>releaseInstance</title>
<para>This method releases the deployment component, such that the next call to
<literal>acquireInstance</literal> will return true.</para>
</formalpara>
<screen>Bool releaseInstance(DeploymentComponent instance);</screen>
<simpara>This method returns true if the deployment component was successfully
released.  It returns false if the deployment component was already not
acquired.</simpara>
<simpara>If the deployment component passed as argument was not created by the cloud
provider, the method returns false.</simpara>
<formalpara>
<title>shutdownInstance</title>
<para>This method shuts down a deployment component.  The effect on the cogs,
objects and running tasks deployed on that deployment component are
backend-specific.</para>
</formalpara>
<screen>Bool shutdownInstance(DeploymentComponent instance);</screen>
<simpara>[Atomic] Rat getAccumulatedCost();</simpara>
<simpara>[Atomic] Map&lt;String, Map&lt;Resourcetype, Rat&gt;&gt; getInstanceDescriptions();</simpara>
</section>
</section>
<section xml:id="sec:deployment-components">
<title>Deployment Components</title>
<simpara>In ABS, processes run inside cogs.  Deployment components are used to provide
a location to cogs.  Cogs residing on the same deployment component share the
resources provided by the deployment component.</simpara>
<figure xml:id="fig-deployment-component">
<title>A deployment component and its cogs</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Deployment-component.png" contentwidth="636" contentdepth="196"/>
</imageobject>
<textobject><phrase>A deployment component and its cogs</phrase></textobject>
</mediaobject>
</figure>
<simpara>Deployment Components are first-class constructs in the ABS language.
References to deployment components can be stored in variables of type
<literal>DeploymentComponent</literal>, and the methods documented in this section can be
called via asynchronous method calls.</simpara>
<simpara>Deployment Components are usually created by a cloud provider instance (see
<xref linkend="sec:cloudprovider"/>), but can also be created using the <literal>new</literal> expression.  A
new cog is created on a deployment component by using a <literal>DC</literal> annotation to the
<literal>new</literal> statement.</simpara>
<note>
<simpara>It is an error to try to create a deployment component via <literal>new local</literal>.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<screen>DeploymentComponent dc = await provider!launchInstance(map[Pair(Speed, 10)]); <co xml:id="CO25-1"/>
[DC: dc] Worker w = new CWorker(); <co xml:id="CO25-2"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO25-1">
<para>The cloud provider <literal>provider</literal> creates a new deployment component <literal>dc</literal> with 10 <literal>Speed</literal> resources</para>
</callout>
<callout arearefs="CO25-2">
<para>A new cog containing a <literal>CWorker</literal> object is created on the new deployment component <literal>dc</literal></para>
</callout>
</calloutlist>
<note>
<simpara>All objects of a cog must reside on the same deployment component, i.e.,
<literal>[DC: x] new local C()</literal> is an error.</simpara>
</note>
<section xml:id="-resources-and-deployment-components">
<title>Resources and Deployment Components</title>
<simpara>As seen above, each deployment component “carries” some amount of resources
for each resource type.  This is expressed as a map from resource type to a
number, for example <literal>map[Pair(Speed, 10), Pair(Bandwidth, 20)]</literal>.  When no
amount is given for some resource type, it is infinite.  See <xref linkend="sec:resources"/>
for a description of the available resource types.</simpara>
</section>
<section xml:id="-methods-2">
<title>Methods</title>
<formalpara>
<title>[Atomic] Rat load(Resourcetype rtype, Int periods)</title>
<para>Return the load (0-100) for the given resource type <literal>rtype</literal> over the last <literal>n</literal>
periods.  If the deployment component was created with infinite resources for
the given resource type, <literal>load</literal> returns <literal>0</literal>.</para>
</formalpara>
<formalpara>
<title>[Atomic] InfRat total(Resourcetype rtype)</title>
<para>Return the total available amount for the given resourcetype.  If the
deployment component was created with infinite resources for the given
resource type, <literal>total</literal> returns <literal>InfRat</literal>, otherwise <literal>Fin(value)</literal>.</para>
</formalpara>
<formalpara>
<title>Unit decrementResources(Rat amount, Resourcetype rtype)</title>
<para>Decrease the total available amount for the given resourcetype by <literal>amount</literal> from
the next time interval onwards.  Trying to decrement infinite resources has no
effect.  It is an error to decrement resources by more than the available amount.</para>
</formalpara>
<formalpara>
<title>Unit incrementResources(Rat amount, Resourcetype rtype)</title>
<para>Increase the total available amount for the given resourcetype by <literal>amount</literal> from
the next time interval onwards.  Trying to increment infinite resources has no
effect.</para>
</formalpara>
<formalpara>
<title>Unit transfer(DeploymentComponent target, Rat amount, Resourcetype rtype)</title>
<para>Transfer <literal>amount</literal> resources of type <literal>rtype</literal> from the current deployment
component to <literal>target</literal>.  Takes effect on the next time period.</para>
</formalpara>
<simpara>(This method is implemented via <literal>decrementResources</literal> and
<literal>incrementResources</literal>.)</simpara>
<formalpara>
<title>[Atomic] String getName()</title>
<para>Returns the name of the deployment component.  Deployment components created
via a <literal>CloudProvider</literal> are guaranteed to have a unique name if no two cloud
providers have the same name.</para>
</formalpara>
<formalpara>
<title>[Atomic] Time getCreationTime()</title>
<para>Get the creation time of the deployment component, in terms of the simulated clock.</para>
</formalpara>
<formalpara>
<title>[Atomic] Rat getStartupDuration()</title>
<para>Get the specified startup duration, or 0 if none specified.</para>
</formalpara>
<formalpara>
<title>[Atomic] Rat getShutdownDuration()</title>
<para>Get the specified shutdown duration, or 0 if none specified.</para>
</formalpara>
<formalpara>
<title>[Atomic] Int getPaymentInterval()</title>
<para>Get the specified payment interval, or 1 if none specified.</para>
</formalpara>
<formalpara>
<title>[Atomic] Rat getCostPerInterval()</title>
<para>Get the specified cost (price) per interval, or 0 if none specified.</para>
</formalpara>
<formalpara>
<title>Bool shutdown()</title>
<para>Shut down the deployment component.  It is an error to create a new object on
a deployment component that has been shutdown, or to invoke a method on an
object residing on a deployment component that has been shut down.</para>
</formalpara>
<formalpara>
<title>[Atomic] CloudProvider getProvider()</title>
<para>Get the cloud provider that manages this deployment component.  Returns <literal>null</literal>
if the deployment component was not created by a cloud provider.  See
<xref linkend="sec:cloudprovider"/> for a discussion of cloud providers.</para>
</formalpara>
<formalpara>
<title>Bool acquire()</title>
<para>Convenience method for calling <literal>acquireInstance</literal> of the associated cloud
provider.  If no cloud provider is set, returns <literal>True</literal>.  See
<xref linkend="sec:cloudprovider"/> for a discussion of cloud providers.</para>
</formalpara>
<formalpara>
<title>Bool release()</title>
<para>Convenience method for calling <literal>releaseInstance</literal> of the associated cloud
provider.  If no cloud provider is set, returns <literal>True</literal>.  See
<xref linkend="sec:cloudprovider"/> for a discussion of cloud providers.</para>
</formalpara>
</section>
</section>
<section xml:id="sec:resources">
<title>Resource Types</title>
<simpara>The term “Resource” can be understood in different ways.  In ABS, we define
“Resource” to be a countable, measurable property of a deployment component.
Some resources stay constant throughout the life of a deployment component
(e.g., the number of cores), some others are influenced by program execution
(e.g., the available bandwidth in the current time slot).</simpara>
<simpara>The resource types currently supported by the ABS language are defined in the
<literal>ABS.DC</literal> module as follows:</simpara>
<screen>data Resourcetype = Speed | Bandwidth | Memory | Cores ;</screen>
<simpara>When a deployment component is created without explicitly giving a value for a
resource type, it is assumed to have an infinite amount of that resource.
E.g., when modeling a denial of service attack, the deployment component
running the attacker code will have infinite speed and bandwidth.</simpara>
<section xml:id="-speed">
<title>Speed</title>
<simpara>The <literal>Speed</literal> resource type models execution speed.  Intuitively, a deployment
component with twice the number of <literal>Speed</literal> resources will execute twice as
fast.  Speed resources are consumed when execution in the current process
reaches a statement that is annotated with a <literal>Cost</literal> annotation.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>Time t1 = now();
[Cost: 5] skip;
Time t2 = now();</screen>
</para>
</formalpara>
<simpara>Executing the above <literal>skip</literal> statement will consume 5 Speed resources from the
deployment component where the cog was deployed.  If the deployment component
does not have infinite Speed resources, executing the <literal>skip</literal> statement might
take an observable amount of time, i.e., <literal>t1</literal> and <literal>t2</literal> might be different.</simpara>
</section>
<section xml:id="-bandwidth">
<title>Bandwidth</title>
<simpara>Bandwidth is a measure of transmission speed.  Bandwidth resources are
consumed during method invocation and <literal>return</literal> statements.  No bandwidth is
consumed if sender and receiver reside on the same deployment component.</simpara>
<simpara>Bandwidth consumption is expressed via a <literal>DataSize</literal> annotation:</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>Time t1 = now();
[DataSize: 2 * length(datalist)] o!process(datalist);
Time t2 = now();</screen>
</para>
</formalpara>
<simpara>Executing the above method invocation statement will consume bandwidth
resources proportional to the length of list <literal>datalist</literal>.</simpara>
</section>
<section xml:id="-memory">
<title>Memory</title>
<simpara>The <literal>Memory</literal> resource type abstracts from the size of main memory, as a measure
of how many and which cogs can be created on a deployment component.  In
contrast to bandwidth and speed, memory does not influence the timed behavior
of the simulation of an ABS model; it is used for static deployment modeling.</simpara>
</section>
<section xml:id="-cores">
<title>Cores</title>
<simpara>The <literal>Cores</literal> resource type expresses the number of CPU cores on a deployment
component.  It is used for static deployment decisions and does not have
influence on the timing behavior of simulations (use the <literal>Speed</literal> resource type
for this purpose).</simpara>
</section>
</section>
<section xml:id="-modeling-resource-usage">
<title>Modeling Resource Usage</title>
<simpara>As described above, resource information is added to statements of an ABS
model using <literal>Cost</literal> and <literal>DataSize</literal> annotations.  Executing such annotated
statements causes observable changes in the simulated time and deployment
component load during simulation.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>module Test;
import * from ABS.DC; <co xml:id="CO26-1"/>
interface I {
  Unit process();
}
class C implements I {
  Unit process() {
    [Cost: 10] skip; <co xml:id="CO26-2"/>
}

{
  DeploymentComponent dc = new DeploymentComponent("Server",
    map[Pair(Speed, 5), Pair(Bandwidth, 10)]);
  [DC: dc] I i = new C();
  [DataSize: 5] i!process(); <co xml:id="CO26-3"/>
}</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO26-1">
<para>Make all necessary identifiers accessible in the current module</para>
</callout>
<callout arearefs="CO26-2">
<para>Executing this statement costs 10 <literal>Speed</literal> units; the time needed depends
on the capacity of the deployment component, and on other cogs executing in
parallel on the same deployment component.</para>
</callout>
<callout arearefs="CO26-3">
<para>Executing this method call consumes 5 Bandwidth resources.  Since <literal>dc</literal> has
10 bandwidth resources per time unit, the message will be transported
instantly.  Executing the <literal>skip</literal> statement in the method body will not finish
instantaneously because <literal>dc</literal> only has 5 <literal>Speed</literal> resources in total.</para>
</callout>
</calloutlist>
</section>
</chapter>
<chapter xml:id="-software-product-line-engineering">
<title>Software Product Line Engineering</title>
<simpara>ABS supports the development of software product lines with a set of language
constructs for defining system variants. Following a feature-oriented
software development approach, variants are described as sets of features.
Features and their dependencies are specified in a feature model.
Each feature has its corresponding ABS implementation. A feature&#8217;s implementation
is specified in terms of the code modifications (i.e., additions and removals)
that need to be performed to a variant of the system that does not include
that feature in order to add it. This style of programming is called
delta-oriented programming. The ABS code modules that encapsulate feature
implementations are called delta modules (deltas).</simpara>
<section xml:id="-delta-oriented-programming">
<title>Delta-Oriented Programming</title>
<simpara>ABS supports the delta-oriented programming model, an approach that aids the
development of a set of programs simultaneously from a single code base,
following the software product line engineering approach.  In delta-oriented
programming, features defined by a feature model are associated with code
modules that describe modifications to a core program.  In ABS, these modules
are called <emphasis>delta modules</emphasis>. Hence the implementation of a software product
line in ABS is divided into a <emphasis>core</emphasis> and a set of delta modules.</simpara>
<simpara>The core consists of a set of ABS modules that implement a complete software
product of the corresponding software product line.  Delta modules (or
<emphasis>deltas</emphasis> in short) describe how to change the core program to obtain new
products.  This includes adding new classes and interfaces, modifying existing
ones, or even removing some classes from the core.  Delta modules can also
modify the functional entities of an ABS program, that is, they can add and
modify data types and type synonyms, and add functions.</simpara>
<simpara>Deltas are applied to the core program by the ABS compiler front end. The
choice of which delta modules to apply depends on the selection of a set of
features, that is, a particular product of the SPL.  The role of the ABS
compiler front end is to translate textual ABS models into an internal
representation and check the models for syntax and semantic errors.  The role
of the back ends is to generate code for the models targeting some suitable
execution or simulation environment.</simpara>
<table frame="topbot" rowsep="0" colsep="0">
<title>Syntax</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<tbody>
<row>
<entry align="right" valign="top"><simpara><emphasis>DeltaDecl</emphasis>      ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>delta</literal> <emphasis>SimpleTypeIdentifier</emphasis> [ <literal>(</literal> <emphasis>DeltaParam</emphasis> { <literal>,</literal> <emphasis>DeltaParam</emphasis> } <literal>)</literal> ] <literal>;</literal><?asciidoc-br?>
 { <emphasis>ModuleAccess</emphasis> } { <emphasis>ModuleModifier</emphasis> }</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>DeltaParam</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Type</emphasis> <emphasis>SimpleIdentifier</emphasis><?asciidoc-br?>
                   | <emphasis>QualifiedTypeIdentifier</emphasis> <emphasis>HasCondition</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>HasCondition</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>hasField</literal> FieldDecl<?asciidoc-br?>
               | <literal>hasMethod</literal> MethSig<?asciidoc-br?>
               | <literal>hasInterface</literal> TypeId</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>ModuleAccess</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>uses</literal> <emphasis>TypeId</emphasis> <literal>;</literal></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>ModuleModifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>adds</literal> <emphasis>ClassDecl</emphasis><?asciidoc-br?>
                    | <literal>removes</literal> <literal>class</literal> <emphasis>TypeIdentifier</emphasis> <literal>;</literal><?asciidoc-br?>
                    | <literal>modifies</literal> <literal>class</literal> <emphasis>TypeIdentifier</emphasis><?asciidoc-br?>
                    &#160; [<literal>adds</literal> <emphasis>TypeIdentifier</emphasis> { <literal>,</literal> <emphasis>TypeIdentifier</emphasis> } ]<?asciidoc-br?>
                    &#160; [<literal>removes</literal> <emphasis>TypeIdentifier</emphasis> { <literal>,</literal> <emphasis>TypeIdentifier</emphasis> } ]<?asciidoc-br?>
                    &#160; <literal>{</literal> { ClassModifier } <literal>}</literal><?asciidoc-br?>
                    | <literal>adds</literal> <emphasis>InterfaceDecl</emphasis><?asciidoc-br?>
                    | <literal>removes</literal> <literal>interface</literal> <emphasis>TypeIdentifier</emphasis> <literal>;</literal><?asciidoc-br?>
                    | <literal>modifies</literal> <literal>interface</literal> <emphasis>TypeIdentifier</emphasis> <literal>{</literal> { <emphasis>InterfaceModifier</emphasis> } <literal>}</literal><?asciidoc-br?>
                    | <literal>adds</literal> <emphasis>FunctionDecl</emphasis><?asciidoc-br?>
                    | <literal>adds</literal> <emphasis>DataTypeDecl</emphasis><?asciidoc-br?>
                    | <literal>modifies</literal> <emphasis>DataTypeDecl</emphasis><?asciidoc-br?>
                    | <literal>adds</literal> <emphasis>TypeSynDecl</emphasis><?asciidoc-br?>
                    | <literal>modifies</literal> <emphasis>TypeSynDecl</emphasis><?asciidoc-br?>
                    | <literal>adds</literal> <emphasis>Import</emphasis><?asciidoc-br?>
                    | <literal>adds</literal> <emphasis>Export</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>ClassModifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>adds</literal> <emphasis>FieldDecl</emphasis><?asciidoc-br?>
               | <literal>removes</literal> <emphasis>FieldDecl</emphasis><?asciidoc-br?>
               | <literal>adds</literal> <emphasis>Method</emphasis><?asciidoc-br?>
               | <literal>modifies</literal> <emphasis>Method</emphasis><?asciidoc-br?>
               | <literal>removes</literal> <emphasis>MethodSig</emphasis></simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><emphasis>InterfaceModifier</emphasis> ::=</simpara></entry>
<entry align="left" valign="top"><simpara><literal>adds</literal> <emphasis>MethSig</emphasis><?asciidoc-br?>
                    | <literal>removes</literal> <emphasis>MethSig</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The <literal>DeltaDecl</literal> clause specifies the syntax of delta modules, consisting of a
unique identifier, a module access directive, a list of parameters and a
sequence of module modifiers.  The <emphasis>module access</emphasis> directive gives the delta
access to the namespace of a particular module.  In other words, it specifies
the ABS module to which modifications using unqualified identifiers apply by
default.  A delta can still make modifications to classes and interfaces in
several modules by fully qualifying the <literal>TypeName</literal> of module modifiers.</simpara>
<simpara>While delta modeling supports a broad range of ways to modify an ABS model,
not all ABS program entities are modifiable.  These unsupported modifications
are listed here for completeness.  While these modifications could be easily
specified and implemented, we opted not to overload the language with features
that have not been regarded as necessary in practice:</simpara>
<variablelist>
<varlistentry>
<term>Class parameters and init block</term>
<listitem>
<simpara>Deltas currently do not support the modification of class parameter lists or
class init blocks.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Deltas</term>
<listitem>
<simpara>currently only support adding functions, and adding and modifying data types
and type synonyms. Removal is not supported.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Modules</term>
<listitem>
<simpara>Deltas currently do not support adding new modules or removing modules.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Imports and Exports</term>
<listitem>
<simpara>While deltas do support the addition of import and export statements to
modules, they do not support their modification or removal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Main block</term>
<listitem>
<simpara>Deltas currently do not support the modification of the program&#8217;s main block.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="-the-feature-model">
<title>The Feature Model</title>
<simpara>Software variability is commonly expressed using features which can be present
or absent from a product of the product line. Features are defined and organised in a
feature model, which is essentially a set of logical constraints expressing
the dependencies between features. Thus the feature model defines a set of
legal feature combinations, which represent the set of valid software variants
that can be built.</simpara>
<section xml:id="-specifying-the-feature-model">
<title>Specifying the Feature Model</title>
<simpara>The <literal>FeatureModel</literal> clause specifies a number of "orthogonal" root feature
models along with a number of extensions that specify additional constraints,
typically cross-tree dependencies.  Its grammar is as follows:</simpara>
<screen>FeatureModel ::= ('root' FeatureDecl)* FeatureExtension*
FeatureDecl  ::= FName [ '{' [Group] AttributeDecl* Constraint* '}' ]
FeatureExtension ::= 'extension' FName '{' AttributeDecl* Constraint* '}'
Group ::= 'group' Cardinality '{' ['opt'] FeatureDecl (',' ['opt'] FeatureDecl)* '}'
Cardinality ::= 'allof' | 'oneof' | '[' IntLiteral '..' Limit ']'
AttributeDecl ::= 'Int' AName ';'
                | 'Int' AName in '[' Limit '..' Limit ']' ';'
                | 'Bool' AName ';'
                | 'String' AName ';'
Limit ::= IntLiteral | '*'
Constraint ::= Expr ';'
             | 'ifin'':'  Expr ';'
             | 'ifout'':' Expr ';'
             | 'require'':' FName ';'
             | 'exclude'':' FName ';'
Expr ::= 'True'
       | 'False'
       | IntLiteral
       | StringLiteral
       | FName
       | AName
       | FName '.'AName
       | UnOp Expr
       | Expr BinOp Expr
       | '(' Expr ')'
UnOp ::= '!' | '-'
BinOp ::= '||' | '&amp;&amp;' | '-&gt;' | '&lt;-&gt;' | '=='
        | '!=' | '&gt;'  | '&lt;'  | '&gt;='  | '&lt;='
        | '+'  | '-'  | '*'  | '/'   | '%'</screen>
<simpara>Attributes and values range over integers, strings or booleans.</simpara>
<simpara>The <literal>FeatureDecl</literal> clause specifies the details of a given feature, firstly by
giving it a name (<literal>FName</literal>), followed by a number of possibly optional
sub-features, the feature&#8217;s attributes and any relevant constraints.</simpara>
<simpara>The <literal>FeatureExtension</literal> clause specifies additional constraints and attributes
for a feature, and if the extended feature has no children a group can also be
specified.  This is particularly useful for specifying constraints that do not
fit into the tree structure given by the root feature model.</simpara>
<simpara>Here is an example feature model for the <literal>DeltaResourceExample</literal> product line,
defining valid combinations of features and valid ranges of parameters for
cost, capacity and number of machines:</simpara>
<screen>root Calculations {
  group oneof {
    Wordcount,
    Wordsearch
  }
}

root Resources {
  group oneof {
    NoCost,
    Cost { Int cost in [ 0 .. 10000 ] ; }
  }
}

root Deployments {
  group oneof {
    NoDeploymentScenario,
    UnlimitedMachines { Int capacity in [ 0 .. 10000 ] ; },
    LimitedMachines { Int capacity in [ 0 .. 10000 ] ;
      Int machinelimit in [ 0 .. 100 ] ; }
  }
}</screen>
</section>
<section xml:id="-feature-model-reflection">
<title>Feature Model Reflection</title>
<simpara>There is support for limited reflection on the feature model and configured
product in the module <literal>ABS.Productline</literal>.  The datatype <literal>Feature</literal> contains
constructors for all feature names.  The function <literal>product_features</literal> returns a
list of features contained in the current product, and <literal>product_name</literal> returns
the name of the product, or the empty string if no product was specified.</simpara>
<simpara>The following sample code shows the usage, assuming that product <literal>Product</literal> was
generated:</simpara>
<screen>module Test;
import * from ABS.Productline;

{
  List&lt;Feature&gt; foo = product_features(); // =&gt; Cons(FeatureA, Cons(FeatureC, Nil))
  String name = product_name();           // =&gt; "Product"
}

productline Test;
features FeatureA, FeatureB, FeatureC;

product Product(FeatureA, FeatureC);</screen>
</section>
</section>
<section xml:id="-software-product-lines-and-products">
<title>Software Product Lines and Products</title>
<simpara>A (software) product line is a set of software variants that can be built by selecting
any combination of features allowed by the feature model and applying the deltas
that provide the implementation for those features to the core program. How features
are associated with their implementation is defined in ABS with a <emphasis>SPL configuration</emphasis>.</simpara>
<simpara>An ABS <emphasis>product</emphasis> is simply a set of features associated with a name.</simpara>
<section xml:id="-specifying-the-product-line">
<title>Specifying the Product Line</title>
<simpara>The ABS configuration language links feature models, which describe the
structure of a SPL, to delta modules, which implement behavior.  The
configuration defines, for each selection of features satisfied by the product
selection, which delta modules should be applied to the core.  Furthermore, it
guides the code generation by ordering the application of the delta modules.</simpara>
<screen>Configuration ::= 'productline' TypeId ';' Features ';' DeltaClause*
Features      ::='features' FName (',' FName)*
DeltaClause   ::= 'delta' DeltaSpec [AfterCondition] [ApplicationCondition] ';'
DeltaSpec     ::= DeltaName ['(' DeltaParams ')']
DeltaName     ::= TypeId
DeltaParams   ::= DeltaParam (',' DeltaParam)*
DeltaParam    ::= FName | FName'.'AName
AfterClause   ::= 'after' DeltaName (',' DeltaName)*
WhenClause    ::= 'when' AppCond
AppCond       ::= AppCond '&amp;&amp;' AppCond
                | AppCond '||' AppCond
                | '!' AppCond
                | '(' AppCond ')'
                | FName</screen>
<simpara>Features and delta modules are associated through <emphasis>application conditions</emphasis> (a.k.a. <emphasis>activation conditions</emphasis>),
which are logical expressions over the set of features and attributes in a
feature model. The collection of applicable delta modules is given by the
application conditions that are true for a particular feature and attribute
selection. By not associating the delta modules directly with features, a
degree of flexibility is obtained.</simpara>
<simpara>Each delta clause has a <literal>DeltaSpec</literal>, specifying the name of a delta module
name and, optionally, a list of parameters; an <literal>AfterClause</literal>, specifying the
delta modules that the current delta must be applied after; and an application
condition <literal>AppCond</literal>, specifying an arbitrary predicate over the feature names
(<literal>FName</literal>) and attribute names (<literal>AName</literal>) in the feature model that describes
when the given delta module is applied.</simpara>
<screen>productline DeltaResourceExample;
features Cost, NoCost, NoDeploymentScenario, UnlimitedMachines, LimitedMachines, Wordcount, Wordsearch;
delta DOccurrences when Wordsearch;
delta DFixedCost(Cost.cost) when Cost;
delta DUnboundedDeployment(UnlimitedMachines.capacity) when UnlimitedMachines;
delta DBoundedDeployment(LimitedMachines.capacity, LimitedMachines.machinelimit) when LimitedMachines;</screen>
</section>
<section xml:id="-specifying-products">
<title>Specifying Products</title>
<simpara>ABS allows the developer to name products that are of particular interest, in
order to easily refer to them later when the actual code needs to be
generated. A product definition states which features are to be included in
the product and sets attributes of those features to concrete values. In the simplest
case products are declared directly, by listing the features that they include.
It is also possible to declare products based on other products using
<emphasis>product expressions</emphasis>. Product expressions use set-theoretic operations (union,
intersection, complement) over products and sets of features.</simpara>
<screen>Selection ::= 'product' TypeId ( '(' FeatureSpecs ')' ';' | '=' ProductExpr ';' )
ProductExpr: '{' FeatureSpecs '}'
			| ProductExpr '&amp;&amp;' ProductExpr
			| ProductExpr '||' ProductExpr
			| ProductExpr '-' ProductExpr
			| TypeId
			| '(' ProductExpr ')'
FeatureSpecs ::= FeatureSpec (',' FeatureSpec)*
FeatureSpec ::= FName [AttributeAssignments]
AttributeAssignments ::= '{' AttributeAssignment (',' AttributeAssignment '}'
AttributeAssignment ::= AName '=' Literal</screen>
<simpara>Here are some product definitions for the <literal>DeltaResourceExample</literal> product line:</simpara>
<screen>product WordcountModel (Wordcount, NoCost, NoDeploymentScenario);
product WordcountFull (Wordcount, Cost{cost=10}, UnlimitedMachines{capacity=20});
product WordsearchFull (Wordsearch, Cost{cost=10}, UnlimitedMachines{capacity=20});
product WordsearchDemo (Wordsearch, Cost{cost=10}, LimitedMachines{capacity=20, machinelimit=2});</screen>
<simpara>Here are some product definitions for the <literal>CharityOrganizationExample</literal> with <literal>ProductExpr</literal>:</simpara>
<screen>product Org1 = SekolahBermainMatahari || {Continuous};
product Org2 = SekolahBermainMatahari || {Continuous, Automatic_Report};
product Org3 = SekolahBermainMatahari || PKPU;
product Org4 = SekolahBermainMatahari || PKPU || RamadhanForKids;
product Org5 = SekolahBermainMatahari || PKPU || RamadhanForKids || BeriBuku;
product Org6 = SekolahBermainMatahari &amp;&amp; RamadhanForKids;
product Org7 = SekolahBermainMatahari &amp;&amp; BeriBuku;
product Org8 = SekolahBermainMatahari - {Eventual};
product Org9 = SekolahBermainMatahari - {Eventual, Income};
product Org10 = SekolahBermainMatahari &amp;&amp; RamadhanForKids || {Money, Item};
product Org11 = SekolahBermainMatahari &amp;&amp; (RamadhanForKids || {Money, Item});</screen>
</section>
<section xml:id="-checking-the-spl">
<title>Checking the SPL</title>
<simpara>Because the number of variants in an SPL can be very large, checking them
efficiently (e.g., to ensure that they are all well-typed) is challenging.
Building each variant in order to type-check it is usually not feasible from a
performance perspective. Instead, the ABS compiler employs a number of efficient
consistency checks. These fall into two categories.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Family-based</emphasis> analysis steps operate on the SPL definition itself,</simpara>
</listitem>
<listitem>
<simpara>Analysis steps operate on lightweight <emphasis>abstractions</emphasis> of the SPL variants.</simpara>
</listitem>
</itemizedlist>
<simpara>These checks are performed automatically upon compilation and help ensure that
all variants defined by an SPL specified in ABS can be built and are well-typed
ABS programs.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="-abs-backends">
<title>ABS Backends</title>
<simpara>This section describes the available and supported backends for ABS.
Different backends have different purposes (simulation, code execution,
visualization).  Their respective section describes their features and usage.</simpara>
<simpara>The following table gives an overview of the features that different backends
have.</simpara>
<variablelist>
<varlistentry>
<term>Real-Time ABS</term>
<listitem>
<simpara>Simulating a dense-time clock, and language constructs
expressing delays and task deadlines.  Used for simulating time usage of ABS
models.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resource Models</term>
<listitem>
<simpara>Specification of resource availability (processor power,
bandwidth) of <emphasis>Deployment Components</emphasis> and simulation of resource usage
deployed thereon.  Builds on the semantics of Real-Time ABS.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Deployment</term>
<listitem>
<simpara>Running ABS code on a number of physical or virtual machines,
with support for creating new cogs remotely.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FLI</term>
<listitem>
<simpara>Foreign-Language Interface, the ability to call backend-specific native
code from ABS.</simpara>
</listitem>
</varlistentry>
</variablelist>
<table frame="all" rowsep="1" colsep="1">
<title>Backend Capabilities</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Backend</entry>
<entry align="left" valign="top">Maude</entry>
<entry align="left" valign="top">Erlang</entry>
<entry align="left" valign="top">Haskell</entry>
<entry align="left" valign="top">Java</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Real-Time ABS</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>yes (deadline implementation missing)</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>User-defined Schedulers</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>partial</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Resource Models</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Deployment</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>?</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FLI</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>planned</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Model API</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="-maude-backend">
<title>Maude Backend</title>
<simpara>The Maude backend is a high-level, executable semantics in rewriting logic of
the ABS language.  Due to its relatively compact nature, it serves as a
test-bed for new language features.</simpara>
<simpara>Executing a model on the Maude backend results in a complete snapshot of the system state after execution has finished.</simpara>
<simpara>The main drawback of the Maude backend is its relatively poor performance, making it not very suitable to simulate large models.</simpara>
<simpara>Features:</simpara>
<itemizedlist>
<listitem>
<simpara>CPU and bandwidth resources</simpara>
</listitem>
<listitem>
<simpara>Simulation of resource usage on deployment components</simpara>
</listitem>
<listitem>
<simpara>Timed semantics</simpara>
</listitem>
<listitem>
<simpara>Executable formal semantics of the ABS language</simpara>
</listitem>
</itemizedlist>
<section xml:id="-how-to-run-the-maude-backend">
<title>How to run the Maude backend</title>
<simpara>Running a model on Maude involves compiling the code, then starting Maude with
the resulting file as input.</simpara>
<simpara>Compiling all files in the current directory into Maude is done with the following command:</simpara>
<literallayout class="monospaced">$ absc -maude *.abs -o model.maude</literallayout>
<simpara>The model is started with the following commands:</simpara>
<literallayout class="monospaced">$ maude
Maude&gt; in model.maude
Maude&gt; frew start .</literallayout>
<simpara>This sequence of commands starts Maude, then loads the compiled model and
starts it.  The resulting output is a dump of the complete system state after
execution of the model finishes.</simpara>
<simpara>In case of problems, check the following:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>absc</literal> should be in the path; check the <literal>PATH</literal> environment variable.</simpara>
</listitem>
<listitem>
<simpara><literal>absfrontend.jar</literal> should be in the environment variable <literal>CLASSPATH</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="-erlang-backend">
<title>Erlang Backend</title>
<simpara>The Erlang backend runs ABS models on the Erlang virtual machine by
translating them into Erlang and combining them with a small runtime library
implementing key ABS concepts (cogs, futures, objects, method invocations) in
Erlang.</simpara>
<simpara>Executing an ABS model in Erlang currently returns the value of the last
statement of the main block; output via <literal>ABS.StdLib.println</literal> is printed on the
console.  For additional introspective and interactive capabilities, the
Erlang backend supports a Model API (see below).</simpara>
<section xml:id="-how-to-run-the-erlang-backend">
<title>How to run the Erlang backend</title>
<simpara>Running a model in Erlang involves compiling the ABS code, then compiling and
running the resulting Erlang code.</simpara>
<simpara>Compiling all files in the current directory into Erlang and starting the
resulting model is done with the following commands:</simpara>
<literallayout class="monospaced">$ absc -erlang *.abs
$ gen/erl/run</literallayout>
<simpara>This sequence of commands starts Erlang, then compiles the generated Erlang
code and starts it.  Type <literal>gen/erl/run -h</literal> for a list of options accepted by
the model.</simpara>
</section>
<section xml:id="-generating-code-coverage-information">
<title>Generating code coverage information</title>
<simpara>The Erlang backend can optionally generate code coverage information in a
format inspired by gnu <literal>gcov</literal> (see
<link xlink:href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html">https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html</link>).  The coverage
information contains line numbers and execution count, but not the source code
itself.  This is sufficient for some tools to visualize code coverage, e.g.,
<literal>cov-mode</literal> for Emacs (<link xlink:href="https://github.com/AdamNiederer/cov">https://github.com/AdamNiederer/cov</link>).</simpara>
<simpara>To generate code coverage information, compile an abs model with the <literal>-cover</literal> switch, then run it as normal, i.e.,</simpara>
<literallayout class="monospaced">$ absc -erlang -cover *.abs
$ gen/erl/run</literallayout>
<simpara>For each <literal>.abs</literal> file, running the model will generate a <literal>.abs.gcov</literal> file in
the directory <literal>gen/erl/absmodel</literal> after the simulation finishes.</simpara>
</section>
</section>
<section xml:id="-haskell-backend">
<title>Haskell Backend</title>
<simpara>The Haskell backend translates ABS models to Haskell source code,
consequently compiled through a Haskell compiler and executed by the machine.
The backend, albeit  a work in progress, already supports most ABS constructs
and, above that, augments the language with extra features, such as <literal>Type Inference</literal>,
<literal>Foreign Imports</literal> and real <literal>Deployment Components</literal>.</simpara>
<formalpara>
<title>Type Inference</title>
<para>With the feature of <literal>Type Inference</literal> enabled, the user can <emphasis>optionally</emphasis> leave out
the declaration of types of certain expressions; the backend will be responsible
to infer those types and type-check them in the ABS program. The type inference
is <emphasis>safe</emphasis>, in the sense that it will not infer any wrong types (soundness property).</para>
</formalpara>
<simpara>To make use of this feature, the user puts an underscore <literal>_</literal> in place
of where a type would normally be, as in this ABS block of code:</simpara>
<programlisting language="java" linenumbering="unnumbered">{ _ x = 3;
  Int y = 4; // type inference is optional
  x = x+y;
  _ l = Cons(x, Cons(y, Nil));
  _ s = length(l) + 4; }</programlisting>
<note>
<simpara>At the moment, the type inference cannot infer
<emphasis>interface types</emphasis> as in <literal>_ o = new Class();</literal>.
It can however infer all the other types, that is Builtin, Algebraic, and Exception data types.
There is a plan to support this in the future.</simpara>
</note>
<formalpara>
<title>Foreign Imports</title>
<para>The Haskell backend extends the ABS module system with the ability
to include Haskell-written code inside the ABS program itself.
This feature is provided by the <literal>foreign_import</literal> keyword,
which syntactically follows that of the normal <literal>import</literal> keyword. To illustrate this:</para>
</formalpara>
<programlisting language="java" linenumbering="unnumbered">module Bar;
...
foreign_import Vertex from Data.Graph;
foreign_import vertices from Data.Graph;</programlisting>
<simpara>the programmer has imported the <literal>Vertex</literal> algebraic datatype and
the <literal>vertices</literal> function from the <literal>Data.Graph</literal> Haskell library module into an ABS module
named <literal>Bar</literal>. Any imported Haskell term will be treated as its ABS
counterpart. In the example case, the programmer may re-export the foreign terms
or use them as normal ABS terms:</simpara>
<screen>{
  Graph g = empty_graph();
  List&lt;Vertex&gt; vs = vertices(g);
}</screen>
<note>
<simpara>At the moment, the ABS programmer can reuse (with <literal>foreign_import</literal>)  Haskell&#8217;s <emphasis>Algebraic Data types</emphasis>
and <emphasis>Pure functions</emphasis>, but not monadic IO code (Haskell code with side-effects). This restriction
is planned to be lifted in a later release of the backend.</simpara>
</note>
<formalpara>
<title>Deployment Components</title>
<para>The Haskell backend implements the ABS feature of Deployment Components, faithfully as described in Chapter 8.
The backend follows the view that Deployment Components are <emphasis>virtual machines</emphasis> running in the Cloud.
As such, each single DC corresponds to one Cloud virtual machine (VM).</para>
</formalpara>
<simpara>Two DC classes (implementations) are provided to support the <link xlink:href="http://opennebula.org/">OpenNebula</link> and
<link xlink:href="http://azure.microsoft.com">Microsoft Azure</link> cloud computing platforms accordingly:</simpara>
<programlisting language="java" linenumbering="unnumbered">class NebulaDC(CPU cpu, Mem memory) implements DC {
  ...
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">class AzureDC(CPU cpu, Mem memory) implements DC {
  ...
}</programlisting>
<simpara>The <literal>CPU</literal> and <literal>Mem</literal> datatypes are passed as arguments when creating the DC to parameterize
its computing resources. These datatypes are simple defined as type synonyms to
Int, but you can expect more sophisticated resource encodings for a future backend release.</simpara>
<screen>type CPU = Int; // processor cores
type Mem = Int; // RAM measured in MB</screen>
<warning>
<simpara>The backend has only been developed on and tested against the OpenNebula platform.
This hopefully will change when more cloud providers will be supported.</simpara>
</warning>
<section xml:id="-how-to-obtain-and-install">
<title>How to obtain and install</title>
<simpara>The compiler itself is written in Haskell and distributed as a normal Haskell package. Therefore to build abs2haskell you need either</simpara>
<simpara>1) a recent release of the <link xlink:href="https://www.haskell.org/platform/">Haskell platform</link> (version &gt;= 2013.2.0.0),</simpara>
<simpara>2) the GHC compiler accompanied by the Cabal packaging system:</simpara>
<itemizedlist>
<listitem>
<simpara>GHC compiler (version &gt;=7.6)</simpara>
</listitem>
<listitem>
<simpara>Cabal package (version &gt;=1.4)</simpara>
</listitem>
<listitem>
<simpara><literal>cabal-install</literal> program. The compiler depends on other community
packages/libraries. This program will automatically fetch
and install any library dependencies.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Downloading, building and installing the compiler</title>
<para>Clone the repository with the command:</para>
</formalpara>
<literallayout class="monospaced">$ git clone git://github.com/bezirg/abs2haskell</literallayout>
<simpara>To build and install the abs2haskell backend run inside the <literal>abs2haskell/</literal> directory:</simpara>
<screen>sudo make install</screen>
</section>
<section xml:id="-how-to-run-the-haskell-backend">
<title>How to run the Haskell backend</title>
<simpara>After installing the compiler, you should
have the program <literal>abs2haskell</literal> under your <literal>PATH</literal>.</simpara>
<simpara>Examples of running:</simpara>
<screen>$ abs2haskell Example.abs

# An ABS program may have multiple main blocks in different modules.
# So you have to specify in which module is the main block you want to build with

$ abs2haskell --main-is=Example.abs Example.abs

$ abs2haskell examples/   # will compile all ABS files under examples directory</screen>
<simpara>The compiler will generate ".hs" files for each compiled ABS module.
No other runtime system libraries and dependencies will be generated.</simpara>
<simpara>The final step before running the ABS program is to compile the generated Haskell code to machine code, as the example:</simpara>
<screen>ghc --make -threaded Example.hs # put the generated haskell file that has the main block here</screen>
<formalpara>
<title>Running the final program</title>
<para>
<screen>./Example -O # means run it on 1 core with default optimizations
./Example -O +RTS -N1 # the same as the above
./Example -O +RTS -N2 # run it on 2 cores
./Example -O +RTS -N4 # run it on 4 cores
./Example -O +RTS -NK # run it on K cores</screen>
</para>
</formalpara>
</section>
</section>
</chapter>
</book>